var documenterSearchIndex = {"docs":
[{"location":"examples/example_QP/#Basic-QP-Example","page":"Problem Description","title":"Basic QP Example","text":"","category":"section"},{"location":"examples/example_QP/","page":"Problem Description","title":"Problem Description","text":"Suppose that we want to solve the following 2-dimensional quadratic programming problem:","category":"page"},{"location":"examples/example_QP/","page":"Problem Description","title":"Problem Description","text":"beginarrayll textminimize   3x_1^2 + 2x_2^2 - x_1 - 4x_2\ntextsubject to   -1 leq x leq 1  x_1 = 2x_2\nendarray","category":"page"},{"location":"examples/example_QP/","page":"Problem Description","title":"Problem Description","text":"We will show how to solve this problem through each of Clarabel's supported languages and interfaces.","category":"page"},{"location":"examples/example_QP/","page":"Problem Description","title":"Problem Description","text":"In each case the first step is to put the problem data into the standard form expected by the solver.","category":"page"},{"location":"examples/example_QP/#Objective-function","page":"Problem Description","title":"Objective function","text":"","category":"section"},{"location":"examples/example_QP/","page":"Problem Description","title":"Problem Description","text":"The Clarabel solver's default configuration expects problem data in the form frac12x^top P x + q^top x.    We therefore define the objective function data as","category":"page"},{"location":"examples/example_QP/","page":"Problem Description","title":"Problem Description","text":"P = 2 cdot beginbmatrix 3  0  0  2endbmatrix\ntextrmand\nq = beginbmatrix -1  -4endbmatrix","category":"page"},{"location":"examples/example_QP/#Constraints","page":"Problem Description","title":"Constraints","text":"","category":"section"},{"location":"examples/example_QP/","page":"Problem Description","title":"Problem Description","text":"The solver's default configuration expects constraints in the form Ax + s = b, where s in mathcalK for some composite cone mathcalK.   We have 1 equality constraint and 4 inequalities, so we require the first element of s to be zero (i.e. the first constraint will correspond to the equality) and all other elements s_i ge 0.   Our cone constraint on s is therefore","category":"page"},{"location":"examples/example_QP/","page":"Problem Description","title":"Problem Description","text":"s in mathcal K = 0^1 times mathbbR^4_ge 0","category":"page"},{"location":"examples/example_QP/","page":"Problem Description","title":"Problem Description","text":"Define the constraint data as","category":"page"},{"location":"examples/example_QP/","page":"Problem Description","title":"Problem Description","text":"A =\nfootnotesizebeginbmatrix*r 1  -2  1  0  0  1  -1  0  0  -1endbmatrix*\ntextrmand\n b=\nfootnotesizebeginbmatrix 0  1  1  1  1 endbmatrix","category":"page"},{"location":"examples/example_QP/","page":"Problem Description","title":"Problem Description","text":"Note that Clarabel expects inputs in Compressed Sparse Column (CSC) format for both P and A.","category":"page"},{"location":"examples/example_SOCP/#Basic-SOCP-Example","page":"Problem Description","title":"Basic SOCP Example","text":"","category":"section"},{"location":"examples/example_SOCP/","page":"Problem Description","title":"Problem Description","text":"Suppose that we want to solve the following 2-dimensional optimization problem:","category":"page"},{"location":"examples/example_SOCP/","page":"Problem Description","title":"Problem Description","text":"beginarrayll textminimize  frac12x_2^22ex\ntextsubject to   leftbeginpmatrix 2x_1  x_2 endpmatrix\n- beginpmatrix 2  2 endpmatrixright_2 le 1\nendarray","category":"page"},{"location":"examples/example_SOCP/","page":"Problem Description","title":"Problem Description","text":"We will show how to solve this problem through each of Clarabel's supported languages and interfaces.","category":"page"},{"location":"examples/example_SOCP/#Objective-function","page":"Problem Description","title":"Objective function","text":"","category":"section"},{"location":"examples/example_SOCP/","page":"Problem Description","title":"Problem Description","text":"The Clarabel solver's default configuration expects problem data in the form frac12x^top P x + q^top x.    We therefore define the objective function data as","category":"page"},{"location":"examples/example_SOCP/","page":"Problem Description","title":"Problem Description","text":"P = 0 cdot beginbmatrix 0  0  0  1endbmatrix\ntextrmand\nq = beginbmatrix 0  0endbmatrix","category":"page"},{"location":"examples/example_SOCP/#Constraints","page":"Problem Description","title":"Constraints","text":"","category":"section"},{"location":"examples/example_SOCP/","page":"Problem Description","title":"Problem Description","text":"The solver's default configuration expects constraints in the form Ax + s = b, where s in mathcalK for some composite cone mathcalK.   We have a single constraint on the 2-norm of a vector, so we rewrite","category":"page"},{"location":"examples/example_SOCP/","page":"Problem Description","title":"Problem Description","text":"leftbeginpmatrix 2x_1  x_2 endpmatrix - beginpmatrix 2  2 endpmatrixright_2 le 1\nquad Longleftrightarrow quad\nbeginpmatrix 1  2x_1 - 2 x_2 - 2 endpmatrix in mathcalK_SOC","category":"page"},{"location":"examples/example_SOCP/","page":"Problem Description","title":"Problem Description","text":"which puts our constraint in the form b - Ax in mathcalK_SOC.   ","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"Source files for Julia examples can be found in examples/jl.","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"EditURL = \"https://github.com/oxfordcontrol/ClarabelDocs/blob/main/examples/jl/example_QP.jl\"","category":"page"},{"location":"examples/jl/example_QP/#Basic-QP-Example-in-Julia","page":"Julia","title":"Basic QP Example in Julia","text":"","category":"section"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"We will show how to solve the Basic QP example problem both natively in Clarabel.jl and also by solving with Clarabel.jl within either JuMP or Convex.jl.","category":"page"},{"location":"examples/jl/example_QP/#Clarabel.jl-native-interface","page":"Julia","title":"Clarabel.jl native interface","text":"","category":"section"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"To solve the problem directly within Clarabel.jl, start by creating the solver and settings:","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"using Clarabel, LinearAlgebra, SparseArrays\n\nsettings = Clarabel.Settings(verbose = true)\nsolver   = Clarabel.Solver()","category":"page"},{"location":"examples/jl/example_QP/#Problem-data","page":"Julia","title":"Problem data","text":"","category":"section"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"Next define the data for the objective function and the constraints:","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"P = sparse([3. 0.;0. 2.].*2)\nq = [-1., -4.]\nnothing  #hide","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"A = sparse([1. -2.;    #<-- LHS of equality constraint\n            1.  0.;    #<-- LHS of inequality constraint (upper bound)\n            0.  1.;    #<-- LHS of inequality constraint (upper bound)\n           -1.  0.;    #<-- LHS of inequality constraint (lower bound)\n            0. -1.;    #<-- LHS of inequality constraint (lower bound)\n            ])\n\nb = [0.;        #<-- RHS of equality constraint\n     ones(4)   #<-- RHS of inequality constraints\n    ]\n\ncones =\n    [Clarabel.ZeroConeT(1),           #<--- for the equality constraint\n     Clarabel.NonnegativeConeT(4)]    #<--- for the inequality constraints\n\n\nnothing  #hide","category":"page"},{"location":"examples/jl/example_QP/#Running-the-solver","page":"Julia","title":"Running the solver","text":"","category":"section"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"Finally, populate the solver with the problem data and solve:","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"Clarabel.setup!(solver, P, q, A, b, cones, settings)\nresult = Clarabel.solve!(solver)","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"then retrieve the solution:","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"result.x","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"tip: Tip\nThere is no constraint on the ordering of the cones that appears in cones as long as it is compatible with the ordering of the constraints as they appear in A and b.   There is also no constraint on the number of instances of each type that appear. You could, for example, define the inequalities in the above example using:```julia cones =     [Clarabel.ZeroConeT(1),           #<–- for the equality constraint      Clarabel.NonnegativeConeT(2),    #<–- first half of the inequality constraints      Clarabel.NonnegativeConeT(2)]    #<–- second half of the inequality constraintsand get the same result.","category":"page"},{"location":"examples/jl/example_QP/#Using-JuMP","page":"Julia","title":"Using JuMP","text":"","category":"section"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"We can solve the same problem a little more easily by using Clarabel.jl as the backend solver within JuMP. Here is the same problem again:","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"using Clarabel, JuMP\n\nmodel = JuMP.Model(Clarabel.Optimizer)\nset_optimizer_attribute(model, \"verbose\", true)\n\n@variable(model, x[1:2])\n@constraint(model, x[1] == 2x[2])\n@constraint(model,  -1 .<= x .<= 1)\n@objective(model, Min, 3x[1]^2 + 2x[2]^2 - x[1] - 4x[2])\n\noptimize!(model)","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"Here is the solution","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"JuMP.value.(x)","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"and the solver termination status again","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"JuMP.termination_status(model)","category":"page"},{"location":"examples/jl/example_QP/#Using-Convex.jl","page":"Julia","title":"Using Convex.jl","text":"","category":"section"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"We can likewise solve the same problem a using Clarabel.jl as the backend solver within Convex.jl.   Here is the same problem one more time:","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"using Clarabel, Convex\n\nx = Variable(2)\nproblem = minimize(3square(x[1]) + 2square(x[2]) - x[1] - 4x[2])\nproblem.constraints = [x[1] == 2x[2]]\nproblem.constraints += [x >= -1; x <= 1]\nsolve!(problem, Clarabel.Optimizer; silent_solver = false)","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"Here is our solution","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"evaluate(x)","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"and the solver termination status again","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"problem.status","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"warning: Warning\nNote that in the Clarabel.jl output that follows the call to solve! using Convex.jl, the problem posed to the solver has been converted to a second-order cone program with a linear objective.   You can see this because now nnz(P) == 0 (there is no quadratic term in the objective) and the solver reports two second order cone constraints.Although the solution will be the same, the required number of iterations and solve time are slightly higher.  When solving problems with quadratic objectives in Clarabel.jl, it is generally preferable to use either the  native Clarabel.jl interface or JuMP, both of which handle quadratic terms in the objective directly.","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"","category":"page"},{"location":"examples/jl/example_QP/","page":"Julia","title":"Julia","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Contributions are always welcome:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Please report any issues and bugs that you encounter in Issues\nAs an open source project we are also interested in any projects and applications that use Clarabel.jl. Please let us know via email to: paul.goulart@eng.ox.ac.uk","category":"page"},{"location":"julia/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"julia/installation/","page":"Installation","title":"Installation","text":"Clarabel.jl can be installed using the Julia package manager for Julia v1.0 and higher. Inside the Julia REPL, type ] to enter the Pkg REPL mode then run","category":"page"},{"location":"julia/installation/","page":"Installation","title":"Installation","text":"pkg> add Clarabel","category":"page"},{"location":"julia/installation/","page":"Installation","title":"Installation","text":"If you want to install the latest version from the github repository run","category":"page"},{"location":"julia/installation/","page":"Installation","title":"Installation","text":"pkg> add Clarabel#main","category":"page"},{"location":"julia/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide describes the process of creating a Clarabel.jl model, populating its settings and problem data, solving the problem and obtaining and understanding results.  The description here relates to Clarabel's native API.  ","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"JuMP / Convex.jl support: We provide an interface to MathOptInterface (MOI), which allows you to describe your problem in JuMP and Convex.jl.  If you want to use JuMP or Convex.jl to model your  problem instead, see the JuMP Interface and Convex.jl Interface sections.","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"Clarabel.jl solves optimisation problems in the format:","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"beginarrayll textminimize  textstylefrac12x^top Px + q^top x textsubject to  Ax + s = b   s in mathcalK endarray","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"with decision variables x in mathbbR^n, s in mathbbR^m and data matrices P=P^top succeq 0, q in mathbbR^n, A in mathbbR^m times n, and b in mathbbR^m.  The convex cone mathcalK is a composition of smaller convex cones mathcalK = mathcalK_1 times mathcalK_2  dots mathcalK_p.   Equality conditions can be modelled in this format using the solver's ZeroCone type.   ","category":"page"},{"location":"julia/getting_started/#Making-a-Solver","page":"Getting Started","title":"Making a Solver","text":"","category":"section"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"The problem data, user settings and workspace variables are all stored in a top level Solver type. To get started define an empty Solver:","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"using Clarabel\nmodel = Clarabel.Solver()","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"It is also possible to specify one or more solver configuration settings at creation time.   See the [Settings][@ref] section below.   ","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"To initialize the solver with an optimisation problem we require three more things:","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"The objective function, i.e. the matrix P and the vector q in frac12x^top P x + q^top x\nThe data matrix A and vector b, along with a description of the composite cone \\mathcal{K} and the dimensions of its constituent pieces.\nA Settings object that specifies how Clarabel.jl solves the problem (optional)","category":"page"},{"location":"julia/getting_started/#Settings","page":"Getting Started","title":"Settings","text":"","category":"section"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"Solver settings are stored in a Settings object and can be modified by the user. To create a Settings object just call the constructor:","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"settings = Clarabel.Settings()","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"To adjust those values, you can pass options and parameters as a key-value pair to the constructor or edit the corresponding field afterwards. For example, if you want to disable verbose printing and set a 5 second time limit on the solver, you can use","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"settings = Clarabel.Settings(verbose = false, time_limit = 5)\n\n# the following is equivalent\nsettings = Clarabel.Settings()\nsettings.verbose    = false\nsettings.time_limit = 5","category":"page"},{"location":"julia/getting_started/#Objective-Function","page":"Getting Started","title":"Objective Function","text":"","category":"section"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"To set the objective function of your optimisation problem simply define the square positive semidefinite matrix P in mathrmR^ntimes n and the vector q in mathrmR^n. Clarabel.jl expects the P matrix to be supplied in sparse format.   The matrix P is assumed by the solver to be symmetric and only values in the upper triangular part of P are needed by the solver.","category":"page"},{"location":"julia/getting_started/#Constraints","page":"Getting Started","title":"Constraints","text":"","category":"section"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"The Clarabel.jl interface expects constraints to be presented in the single vectorized form Ax + s = b s in mathcalK, where mathcalK = mathcalK_1 times dots times mathcalK_p and each mathcalK_i is one of the  cones defined below:","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"Cone Type Description\nZeroConeT The set  0 ^dim that contains the origin\nNonnegativeConeT The nonnegative orthant  x in mathbbR^dim  x_i ge 0 forall i=1dotsmathrmdim \nSecondOrderConeT The second-order (Lorenz) cone  (tx) in mathbbR^dim    x_2   leq t ","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"Suppose that we have a problem with decision variable x in mathbbR^3 and our constraints are:","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"A single equality constraint x_1 + x_2 - x_3 = 1.   \nA pair of inequalities such that x_2 and x_3 are each less than 2.\nA second order cone constraint on the 3-dimensional vector x.   ","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"We can then define our constraint data as","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"using SparseArrays\n\n# equality constraint\nAeq = [1 1 -1]\nbeq = [1]\n\n# inequality constraint\nAineq = [0 1 0;\n         0 0 1]\nbineq = [2,2]\n\n# SOC constraint\nAsoc = -I(3)\nbsoc = [0,0,0]\n\n#Clarabel.jl constraint data\nA = sparse([Aeq; Aineq; Asoc])\nb = [beq;bineq;bsoc]","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"Clarabel.jl expects to receive a vector of cone specifications.  For the above constraints we  should also define","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"#Clarabel.jl cone specification\ncones = [Clarabel.ZeroConeT(1), Clarabel.NonnegativeConeT(2), SecondOrderConeT(3)]","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nThe cones cones' should be of typeVector{Clarabel.SupportedCone}, and your input vectorb` should be compatible with the sum of the cone dimensions.","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nNote carefully the signs in the above example.   The inequality condition is A_ineq x le b_ineq, which is equivalent to A_ineq x + s = b_ineq with s ge 0, i.e. s in the Nonnegative cone.    The SOC condition is x in mathcalK_SOC, or equivalently -x + s = 0 with s in mathcalK_SOC.","category":"page"},{"location":"julia/getting_started/#Adding-problem-data","page":"Getting Started","title":"Adding problem data","text":"","category":"section"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"Once the objective function and an array of constraints have been defined, you can provide the solver with problem data using","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"Clarabel.setup!(solver, P, q, A, b, cones, settings)","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"This takes an internal copy of all data parameters and initializes internal variables and other objects in the solver.  The final settings argument is optional.","category":"page"},{"location":"julia/getting_started/#Solving","page":"Getting Started","title":"Solving","text":"","category":"section"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"Now you can solve it using:","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"result = Clarabel.solve!(solver)","category":"page"},{"location":"julia/getting_started/#Results","page":"Getting Started","title":"Results","text":"","category":"section"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"Once the solver algorithm terminates you can inspect the solution using the solution object.   The primal solution will be in solution.x and the dual solution in solution.z. The outcome of the solve is specified in solution.status and will be one of the following :","category":"page"},{"location":"julia/getting_started/#Status-Codes","page":"Getting Started","title":"Status Codes","text":"","category":"section"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"Status Code Description\nUNSOLVED Default value, only occurs prior to calling Clarabel.solve!\nSOLVED Solution found\nPRIMAL_INFEASIBLE Problem is primal infeasible\nDUAL_INFEASIBLE Problem is dual infeasible\nMAX_ITERATIONS Solver halted after reaching iteration limit\nMAX_TIME Solver halted after reaching time limit","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"The total solution time (include combined setup! and solve! times) is given in solution.solve_time.   Detailed information about the solve time and memory allocation can be found in the solver's timer field.","category":"page"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"warning: Warning\nBe careful to retrieve solver solutions from the solution that is returned by the solver, or directly from a solver object from the solver.solution field.   Do not use the solver.variables, since these have both homogenization and equilibration scaling applied and therefore do not solve the optimization problem posed to the solver.","category":"page"},{"location":"julia/getting_started/#Settings-2","page":"Getting Started","title":"Settings","text":"","category":"section"},{"location":"julia/getting_started/","page":"Getting Started","title":"Getting Started","text":"The full set of user configurable solver settings are listed in the API Reference","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"Source files for Julia examples can be found in examples/jl.","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"EditURL = \"https://github.com/oxfordcontrol/ClarabelDocs/blob/main/examples/jl/example_SOCP.jl\"","category":"page"},{"location":"examples/jl/example_SOCP/#Basic-SOCP-Example-in-Julia","page":"Julia","title":"Basic SOCP Example in Julia","text":"","category":"section"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"We will show how to solve this problem both natively in Clarabel.jl and also by solving with Clarabel.jl within JuMP.","category":"page"},{"location":"examples/jl/example_SOCP/#Clarabel.jl-native-interface","page":"Julia","title":"Clarabel.jl native interface","text":"","category":"section"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"To solve the problem directly within Clarabel.jl, start by creating the solver and settings:","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"using Clarabel, LinearAlgebra, SparseArrays\n\nsettings = Clarabel.Settings(verbose = true)\nsolver   = Clarabel.Solver()","category":"page"},{"location":"examples/jl/example_SOCP/#Objective-function-data","page":"Julia","title":"Objective function data","text":"","category":"section"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"Next define the data for the objective function and the constraints:","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"P = sparse([0. 0.;0. 1.].*2)\nq = [0., 0.]\nnothing  #hide","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"A = sparse([0.  0.\n           -2.  0.;\n            0. -1.])\nb = [ 1.\n     -2.;\n     -2.]\n\ncones = [Clarabel.SecondOrderConeT(3)]\n\nnothing  #hide","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"Finally populate the solver with problem data and solve:","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"Clarabel.setup!(solver, P, q, A, b, cones, settings)\nresult = Clarabel.solve!(solver)","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"then retrieve the solution:","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"result.x","category":"page"},{"location":"examples/jl/example_SOCP/#Using-JuMP","page":"Julia","title":"Using JuMP","text":"","category":"section"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"We can solve the same problem using Clarabel.jl as the backend solver within JuMP. Here is the same problem again:","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"using Clarabel, JuMP\n\nmodel = JuMP.Model(Clarabel.Optimizer)\nset_optimizer_attribute(model, \"verbose\", true)\n\n@variable(model, x[1:2])\n@constraint(model, [1, 2x[1]-2, x[2] - 2] in SecondOrderCone())\n@objective(model, Min, x[2]^2 )\n\noptimize!(model)","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"Here is the solution","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"JuMP.value.(x)","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"and the solver termination status again","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"JuMP.termination_status(model)","category":"page"},{"location":"examples/jl/example_SOCP/#Using-Convex.jl","page":"Julia","title":"Using Convex.jl","text":"","category":"section"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"One more time using Clarabel.jl as the backend solver within Convex.jl:","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"using Clarabel, Convex\n\nx = Variable(2)\nproblem = minimize(square(x[2]))\nproblem.constraints = [norm([2x[1];x[2]] - [2;2], 2) <= 1]\nsolve!(problem, Clarabel.Optimizer; silent_solver = false)","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"Here is our solution","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"evaluate(x)","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"and the solver termination status again","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"problem.status","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"","category":"page"},{"location":"examples/jl/example_SOCP/","page":"Julia","title":"Julia","text":"This page was generated using Literate.jl.","category":"page"},{"location":"julia/jump/#JuMP-Interface","page":"JuMP Interface","title":"JuMP Interface","text":"","category":"section"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"Clarabel.jl implements support for MathOptInterface, and is therefore compatible with JuMP.   This allows you to describe and modify your optimisation problem with JuMP and use Clarabel.jl as the backend solver.","category":"page"},{"location":"julia/jump/#Setting-Clarabel.jl-Backend","page":"JuMP Interface","title":"Setting Clarabel.jl Backend","text":"","category":"section"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"To specify Clarabel.jl as the solver for your JuMP model, load the solver module with using Clarabel and then configure Clarabel as the solver backend when initialising the JuMP model:","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"model = JuMP.Model(Clarabel.Optimizer)","category":"page"},{"location":"julia/jump/#Solver-Settings","page":"JuMP Interface","title":"Solver Settings","text":"","category":"section"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"Solver-specific settings can be passed after the Clarabel.Optimizer object. For example, if you want to adjust the maximum number of iterations and turn off verbose printing use","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"set_optimizer_attribute(model, \"verbose\", true)\nset_optimizer_attribute(model, \"max_iter\", 25)","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"The full list of available settings can be found in the Settings section of the API Reference.","category":"page"},{"location":"julia/jump/#Results","page":"JuMP Interface","title":"Results","text":"","category":"section"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"After solving the problem the result can be obtained using the standard JuMP commands. To see if the optimisation was successful use","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"JuMP.termination_status(model)\nJuMP.primal_status(model)","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"If a solution is available, the optimal objective value can be retrieved using","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"JuMP.objective_value(model)","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"and the value of a decision variable x can be obtained with","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"JuMP.value.(x)","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"For more information on JuMP, see the JuMP documentation.","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"EditURL = \"https://github.com/oxfordcontrol/ClarabelDocs/blob/main/docs/src/literate/convex_jl.jl\"","category":"page"},{"location":"literate/build/convex_jl/#Convex.jl-Interface","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"Clarabel.jl implements support for MathOptInterface, and is therefore compatible with Convex.jl.   This allows you to describe and modify your optimisation problem with Convex.jl and use Clarabel as the backend solver.","category":"page"},{"location":"literate/build/convex_jl/#Setting-Clarabel.jl-Backend","page":"Convex.jl Interface","title":"Setting Clarabel.jl Backend","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"You should construct your problem in the usual way in Convex.jl, and then solve using Clarabel.Optimizer, i.e. by calling solve! with","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"solve!(problem, Clarabel.Optimizer)","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"where problem is an object of type Convex.Problem.","category":"page"},{"location":"literate/build/convex_jl/#Convex.jl-or-JuMP?","page":"Convex.jl Interface","title":"Convex.jl or JuMP?","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"Clarabel.jl supports both Convex.jl and JuMP via MathOptInterface.   Both packages are excellent and can make problem construction considerably easier than via the solver's native interface.","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"For problems with quadratic objective functions, JuMP is generally preferred when using Clarabel.jl since it will keep the quadratic function in the objective rather than reformulating the problem to a form with a linear cost and additional second-order cone constraints.   Clarabel.jl natively supports quadratic objectives and solve times are generally faster if this reformulation is avoided.","category":"page"},{"location":"literate/build/convex_jl/#Arbitrary-Precision-Arithmetic","page":"Convex.jl Interface","title":"Arbitrary Precision Arithmetic","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"Clarabel.jl supports arbitrary precision arithmetic for Convex.jl.   Here is the Basic QP Example implemented using BigFloat types.","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"#hide setprecision(BigFloat,256)\nusing Clarabel, Convex\n\nx = Variable(2)\nobjective = 3square(x[1]) + 2square(x[2]) - x[1] - 4x[2]\nproblem = minimize(objective; numeric_type = BigFloat)\nproblem.constraints = [x[1] == 2x[2]]\nproblem.constraints += [x >= -1; x <= 1]\nsolve!(problem, Clarabel.Optimizer{BigFloat}; silent_solver = false)","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api-jl/#Julia-API-Reference","page":"Julia API","title":"Julia API Reference","text":"","category":"section"},{"location":"api-jl/#api-solver","page":"Julia API","title":"Solver and main API","text":"","category":"section"},{"location":"api-jl/","page":"Julia API","title":"Julia API","text":"Clarabel.Solver\nClarabel.setup!\nClarabel.solve!","category":"page"},{"location":"api-jl/#Clarabel.Solver","page":"Julia API","title":"Clarabel.Solver","text":"Solver{T <: AbstractFloat}()\n\nInitializes an empty Clarabel solver that can be filled with problem data using:\n\nsetup!(solver, P, q, A, b, cones, [settings]).\n\n\n\n\n\n","category":"type"},{"location":"api-jl/#Clarabel.setup!","page":"Julia API","title":"Clarabel.setup!","text":"setup!(solver, P, q, A, b, cones, [settings])\n\nPopulates a Solver with a cost function defined by P and q, and one or more conic constraints defined by A, b and a description of a conic constraint composed of cones whose types and dimensions are specified by cones.\n\nThe solver will be configured to solve the following optimization problem:\n\nmin   1/2 x'Px + q'x\ns.t.  Ax + s = b, s ∈ K\n\nAll data matrices must be sparse.   The matrix P is assumed to be symmetric and positive semidefinite, and only the upper triangular part is used.\n\nThe cone K is a composite cone.   To define the cone the user should provide a vector of cone specifications along with the appropriate dimensional information.   For example, to generate a cone in the nonnegative orthant followed by a second order cone, use:\n\ncones = [Clarabel.NonnegativeConeT(dim_1),\n         Clarabel.SecondOrderConeT(dim_2)]\n\nIf the argument 'cones' is constructed incrementally, the should should initialize it as an empty array of the supertype for all allowable cones, e.g.\n\ncones = Clarabel.SupportedCone[]\npush!(cones,Clarabel.NonnegativeConeT(dim_1))\n...\n\nThe optional argument settings can be used to pass custom solver settings:\n\nsettings = Clarabel.Settings(verbose = true)\nsetup!(model, P, q, A, b, cones, settings)\n\nTo solve the problem, you must make a subsequent call to solve!\n\n\n\n\n\n","category":"function"},{"location":"api-jl/#Clarabel.solve!","page":"Julia API","title":"Clarabel.solve!","text":"solve!(solver)\n\nComputes the solution to the problem in a Clarabel.Solver previously defined in setup!.\n\n\n\n\n\n","category":"function"},{"location":"api-jl/#api-cones","page":"Julia API","title":"Supported Cone Types","text":"","category":"section"},{"location":"api-jl/","page":"Julia API","title":"Julia API","text":"Clarabel.SupportedCone","category":"page"},{"location":"api-jl/#Clarabel.SupportedCone","page":"Julia API","title":"Clarabel.SupportedCone","text":"SupportedCone\n\nAn abstract type use by the Clarabel API used when passing cone specifications to the solver setup!. The currently supported concrete types are:\n\nZeroConeT       : The zero cone.  Used to define equalities.\nNonnegativeConeT: The nonnegative orthant.\nSecondOrderConeT: The second order / Lorentz / ice-cream cone.\n\nPSDTriangleConeT: The positive semidefinite cone (triangular format).\n\n\n\n\n\n","category":"type"},{"location":"api-jl/#api-settings","page":"Julia API","title":"Settings","text":"","category":"section"},{"location":"api-jl/","page":"Julia API","title":"Julia API","text":"Clarabel.Settings","category":"page"},{"location":"api-jl/#Clarabel.Settings","page":"Julia API","title":"Clarabel.Settings","text":"Clarabel.Settings{T}(kwargs) where {T <: AbstractFloat}\n\nCreates a Clarabel Settings object that is used to pass user settings to the solver.\n\nArgument Default Value Description\n  \nMain Algorithm Settings  \n  \nmax_iter 50 maximum number of iterations\ntime_limit 0 maximum run time (seconds)\nverbose true verbose printing\ntol_gap_abs 1e-8 absolute residual tolerance\ntol_gap_rel 1e-8 relative residual tolerance\ntol_feas 1e-5 feasibility check tolerance\ntol\\infeas\\abs 1e-8 absolute infeasibility tolerance\ntol\\infeas\\rel 1e-8 relative infeasibility tolerance\nmax_step_fraction 0.99 maximum interior point step length\n  \nData Equilibration Settings  \n  \nequilibrate_enable true enable  data equilibration pre-scaling\nequilibrate_max_iter 10 maximum equilibration scaling iterations\nequilibrate_min_scaling 1e-4 minimum equilibration scaling allowed\nequilibrate_max_scaling 1e+4 maximum equilibration scaling allowed\n  \nLinear Solver Settings  \n  \ndirect_kkt_solver true use a direct linear solver method (required true)\ndirect_solve_method :qdldl direct linear solver (:qdldl, :mkl or :cholmod)\nstatic_regularization_enable true enable KKT static regularization\nstatic_regularization_eps 1e-8 KKT static regularization parameter\ndynamic_regularization_enable true enable KKT dynamic regularization\ndynamic_regularization_eps 1e-13 KKT dynamic regularization threshold\ndynamic_regularization_delta 2e-7 KKT dynamic regularization shift\niterative_refinement_enable true KKT solve with iterative refinement\niterative_refinement_reltol 1e-10 iterative refinement relative tolerance\niterative_refinement_abstol 1e-10 iterative refinement absolute tolerance\niterative_refinement_max_iter 10 iterative refinement maximum iterations\niterative_refinement_stop_ratio 2.0 iterative refinement stalling tolerance\n\n\n\n\n\n","category":"type"},{"location":"api-jl/#api-solverstatus","page":"Julia API","title":"Solver Status","text":"","category":"section"},{"location":"api-jl/","page":"Julia API","title":"Julia API","text":"Clarabel.SolverStatus","category":"page"},{"location":"api-jl/#Clarabel.SolverStatus","page":"Julia API","title":"Clarabel.SolverStatus","text":"SolverStatus\n\nAn Enum of of possible conditions set by solve!.\n\nIf no call has been made to solve!, then the SolverStatus is:\n\nUNSOLVED: The algorithm has not started.\n\nOtherwise:\n\nSOLVED              : Solver as terminated with a solution.\nPRIMAL_INFEASIBLE   : Problem is primal infeasible.  Solution returned is a certificate of primal infeasibility.\nDUAL_INFEASIBLE     : Problem is dual infeasible.  Solution returned is a certificate of dual infeasibility.\nMAX_ITERATIONS      : Iteration limit reached before solution or infeasibility certificate found.\nMAX_TIME            : Time limit reached before solution or infeasibility certificate found.\n\n\n\n\n\n","category":"type"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"EditURL = \"https://github.com/oxfordcontrol/ClarabelDocs/blob/main/docs/src/literate/arbitrary_precision.jl\"","category":"page"},{"location":"literate/build/arbitrary_precision/#Arbitrary-Precision-Arithmetic","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"","category":"section"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.jl supports the use of arbitrary precision floating-point types, including Julia's BigFloat type.  To use this feature you must specify all of your problem data using a common floating point type and explictly create Clarabel.Solver and (optional) Clarabel.Settings objects of the the same type.","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Start by creating the solver and settings with the desired precision:","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"using Clarabel, LinearAlgebra, SparseArrays\n\nsettings = Clarabel.Settings{BigFloat}(\n            verbose = true,\n            direct_kkt_solver = true,\n            direct_solve_method = :qdldl)\n\nsolver   = Clarabel.Solver{BigFloat}()","category":"page"},{"location":"literate/build/arbitrary_precision/#Objective-and-constraint-data","page":"Arbitrary Precision Arithmetic","title":"Objective and constraint data","text":"","category":"section"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"We next put the objective function into the standard Clarabel.jl form.   Here we use the same problem data as in the Basic QP Example, but in BigFloat format :","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"P = sparse(BigFloat[3. 0.;0. 2.].*2)\nq = BigFloat[-1., -4.]\nA = sparse(\n    BigFloat[1. -2.;    #<-- LHS of equality constraint\n             1.  0.;    #<-- LHS of inequality constraint (upper bound)\n             0.  1.;    #<-- LHS of inequality constraint (upper bound)\n            -1.  0.;    #<-- LHS of inequality constraint (lower bound)\n             0. -1.;    #<-- LHS of inequality constraint (lower bound)\n    ])\nb = [zero(BigFloat);    #<-- RHS of equality constraint\n     ones(BigFloat,4)   #<-- RHS of inequality constraints\n    ]\n\ncones =\n    [Clarabel.ZeroConeT(1),           #<--- for the equality constraint\n     Clarabel.NonnegativeConeT(4)]    #<--- for the inequality constraints\n\nnothing  #hide","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"You can optionally set the global precision of Julia's BigFloat type before solving","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"setprecision(BigFloat,128)\nnothing  #hide","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Finally we can set up the problem in the usual way and solve","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.setup!(solver, P, q, A, b, cones, settings)\nresult = Clarabel.solve!(solver)\n\n#then retrieve the solution\n\nresult.x","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Notice that the above would fail if the default solver was used, because Clarabel.jl uses Float64 by default","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.Solver()","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"warning: Warning\nFor arbitrary precision arithmetic using BigFloat types you must select an internal linear solver within Clarabel.jl that supports it.   We recommend that you use the QDLDL.jl package for such problems, and configure it as the linear solver by setting both direct_kkt_solver = true and direct_solve_method = :qdldl in the Settings object.","category":"page"},{"location":"literate/build/arbitrary_precision/#With-Convex.jl-/-JuMP","page":"Arbitrary Precision Arithmetic","title":"With Convex.jl / JuMP","text":"","category":"section"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.jl also supports arbitrary precision arithmetic through Convex.jl.   See the example in the Convex.jl Interface section.","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"note: Note\nJuMP does not currently support arbitrary precision. However, if you want to use Clarabel directly with MathOptInterface, you can use: Clarabel.Optimizer{<: AbstractFloat} as your optimizer.  As above, the problem data precision of your MathOptInterface-model must agree with the optimizer's precision.","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"This page was generated using Literate.jl.","category":"page"},{"location":"python/getting_started/#Getting-Started","page":"Python","title":"Getting Started","text":"","category":"section"},{"location":"python/getting_started/","page":"Python","title":"Python","text":"Getting started with Python ...","category":"page"},{"location":"python/getting_started/#Installation-from-Source","page":"Python","title":"Installation from Source","text":"","category":"section"},{"location":"python/getting_started/","page":"Python","title":"Python","text":"Blah blah","category":"page"},{"location":"python/getting_started/#Installation-from-Conda","page":"Python","title":"Installation from Conda","text":"","category":"section"},{"location":"python/getting_started/","page":"Python","title":"Python","text":"Blah Blah","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"Complete Cargo projects for all Rust examples can be found in examples/rs.","category":"page"},{"location":"examples/rs/example_QP/#Basic-QP-Example-in-Rust","page":"Rust","title":"Basic QP Example in Rust","text":"","category":"section"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"We will show how to solve the Basic QP example using Rust.   It is assumed here that you are building your project using cargo.","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"The first step is to add the solver to your project's Cargo.toml file like so:","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"[dependencies]\nclarabel = \"0.1\"  ","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"Then bring the solver into scope in your source files:","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"use clarabel::algebra::*;\nuse clarabel::solver::*;","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"The algebra module defines the CscMatrix type for defining matrices in compressed sparse column format.   It also contains some basic utilities for creating and manipulating sparse matrices.","category":"page"},{"location":"examples/rs/example_QP/#Problem-data","page":"Rust","title":"Problem data","text":"","category":"section"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"Next define the data for the objective function and the constraints:","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"let P = CscMatrix::new(\n    2,             // m\n    2,             // n\n    vec![0, 1, 2], // colptr\n    vec![0, 1],    // rowval\n    vec![6., 4.],  // nzval\n);\n\nlet q = vec![-1., -4.];","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"tip: Tip\nYou are only required to specify the upper triangular part of the matrix P since it is assumed symmetric. Any entries in the matrix P that appear below the main diagonal will be ignored.","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"tip: Tip\nTo specify P = I, you can uselet P = CscMatrix::identity(2);where in this case we have had to be specific about the floating point data type we want.   To use a zero matrix (e.g. if solving an LP), you can uselet P = CscMatrix::spalloc(2,2,0);to construct a sparse matrix with no entries.","category":"page"},{"location":"examples/rs/example_QP/#Constraint-data","page":"Rust","title":"Constraint data","text":"","category":"section"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"\nlet A = CscMatrix::new(\n    5,                               // m\n    2,                               // n\n    vec![0, 3, 6],                   // colptr\n    vec![0, 1, 3, 0, 2, 4],          // rowval\n    vec![1., 1., -1., -2., 1., -1.], // nzval\n);\n\nlet b = vec![0., 1., 1., 1., 1.];\n\nlet cones = [ZeroConeT(1), NonnegativeConeT(4)];\n","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"tip: Tip\nThere is no constraint on the ordering of the cones that appears in cones as long as it is compatible with the ordering of the constraints as they appear in A and b.   There is also no constraint on the number of instances of each type that appear. You could, for example, define the inequalities in the above example using:cones =\n    [ZeroConeT(1),           #<--- for the equality constraint\n     NonnegativeConeT(2),    #<--- first half of the inequality\n     NonnegativeConeT(2)];   #<--- second half of the inequality","category":"page"},{"location":"examples/rs/example_QP/#Solver-settings","page":"Rust","title":"Solver settings","text":"","category":"section"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"Next construct a settings structure to pass to the solver.   This can be done using the DefaultSettingsBuilder method to specify custom settings.   For example, to run with equilibration enabled (although it is already enabled by default) and max_iter = 50, use:","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"let settings = DefaultSettingsBuilder::default()\n    .equilibrate_enable(true)\n    .max_iter(50)\n    .build()\n    .unwrap();","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"Alternatively, you can just specify the defaults directly using:","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"let settings = DefaultSettings::default();","category":"page"},{"location":"examples/rs/example_QP/#Running-the-solver","page":"Rust","title":"Running the solver","text":"","category":"section"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"Finally populate the solver with problem data and solve:","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"let mut solver = DefaultSolver::new(&P, &q, &A, &b, &cones, settings);\n\nsolver.solve();","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"then retrieve the solution:","category":"page"},{"location":"examples/rs/example_QP/","page":"Rust","title":"Rust","text":"println!(\"Solution = {:?}\", solver.solution.x);","category":"page"},{"location":"api-rs/","page":"Rust API ⧉","title":"Rust API ⧉","text":"    <head>\n        <title>Old Page</title>\n     <meta charset=\"UTF-8\" />\n     <meta http-equiv=\"refresh\" content=\"0; URL=https://www.docs.rs/\" />\n   </head>\n   <body>\n     <p>Clarabel.rs API documentation is at <a href=\"https://www.docs.rs/\">https://www.docs.rs/</a>. Trying to redirect you...</p>\n   </body>","category":"page"},{"location":"rust/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"rust/getting_started/","page":"Getting Started","title":"Getting Started","text":"Getting started with Rust...","category":"page"},{"location":"julia/linear_solvers/#Linear-System-Solvers","page":"Linear Solvers","title":"Linear System Solvers","text":"","category":"section"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"The primary numerical operation inside Clarabel.jl is the solution of a symmetric quasidefinite linear system at each iteration.  The solver currently supports three different solvers to perform factorization and forward/backward substitution on this system.","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"The linear solver can be configured in Settings using the direct_solve_method field, e.g.","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"settings = Solver.Settings(direct_solve_method = :qdldl)","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"The solvers currently supported are","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"Symbol Package Description\n:qdldl QDLDL.jl Default solver\n:mkl Pardiso.jl Intel MKL Pardiso\n:cholmod Julia native ldlt solver SuiteSparse.CHOLMOD","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"note: Note\nTo use the MKL Pardiso solver you must install the respective libraries and the corresponding Julia wrapper. For more information about installing these, visit the Pardiso.jl repository page.","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"QDLDL is a single threaded solver written in pure Julia, and is generally adequate for problems of small to medium size.   The MKL Pardiso solver is multi-threaded and may be preferred for very large problem instances, or problems in which the problem data is extremely dense.","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"Support for additional linear system solvers may be implemented in future releases.   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clarabel is an interior point numerical solver for convex optimization problems using a novel homogeneous embedding.  The Clarabel package solves the following problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginarrayll textminimize  textstylefrac12x^top Px + q^top x textsubject to  Ax + s = b   s in mathcalK\nendarray","category":"page"},{"location":"","page":"Home","title":"Home","text":"with decision variables x in mathbbR^n, s in mathbbR^m and data matrices P=P^top succeq 0, q in mathbbR^n, A in mathbbR^m times n, and b in mathbbR^m. The convex set mathcalK is a composition of convex cones.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clarabel is available in either a native Julia or a native Rust implementation, with a Python interface also available for the Rust version.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Versatile: Clarabel solves linear programs (LPs), quadratic programs (QPs), second-order cone programs (SOCPs) and semidefinite programs (SDPs).  Future versions will provide support for problems involving exponential and power cones.\nQuadratic objectives: Unlike interior point solvers based on the standard homogeneous self-dual embedding (HSDE) model, Clarabel.jl handles quadratic objective without requiring any epigraphical reformulation of its objective function.   It can therefore be significantly faster than other HSDE-based solvers for problems with quadratic objective functions.\nInfeasibility detection: Infeasible problems are detected using using a homogeneous embedding technique.s\nArbitrary precision types: You can solve problems with any floating point precision, e.g. Float32 or Julia's BigFloat type in Julia and f32 or f64 types in Rust.\nOpen Source: Our code is available on GitHub and distributed under the Apache 2.0 License.   The Julia implementation is here.   The Rust implementation and Python interface is here.","category":"page"},{"location":"#Credits","page":"Home","title":"Credits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following people are involved in the development of Clarabel.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Paul Goulart (main development, maths and algorithms)\nYuwen Chen (maths and algorithms)","category":"page"},{"location":"","page":"Home","title":"Home","text":"All contributors are affiliated with the Control Group of the Department of Engineering Science at the University of Oxford.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If this project is useful for your work please consider","category":"page"},{"location":"","page":"Home","title":"Home","text":"Citing the relevant papers\nLeaving a star on the GitHub repository","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clarabel.jl is licensed under the Apache License 2.0. For more details click here.","category":"page"},{"location":"citing/","page":"Citing Clarabel","title":"Citing Clarabel","text":"A paper describing the Clarabel solver algorithm and implementation will be forthcoming soon.   Until then, we ask that you cite this documentation if you have found Clarabel.jl useful in your work.","category":"page"},{"location":"examples/jl/README/","page":"-","title":"-","text":"Julia examples in this directory are automatically built from the <repo>/examples/jl using the Literate.jl package during documentation build.","category":"page"}]
}
