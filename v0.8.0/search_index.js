var documenterSearchIndex = {"docs":
[{"location":"api_rs/#api-ref-rust","page":"Rust API ⧉","title":"Rust API Reference","text":"","category":"section"},{"location":"api_rs/","page":"Rust API ⧉","title":"Rust API ⧉","text":"    <head>\n        <title>Old Page</title>\n     <meta charset=\"UTF-8\" />\n     <meta http-equiv=\"refresh\" content=\"0; URL=https://docs.rs/clarabel/\" />\n   </head>\n   <body>\n     <p>Clarabel.rs API documentation is at <a href=\"https://www.docs.rs/\">https://docs.rs/clarabel/</a>. Trying to redirect you...</p>\n   </body>","category":"page"},{"location":"python/getting_started_py/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"This section describes the process of creating a Clarabel model directly in Python, populating its settings and problem data, solving the problem and obtaining and understanding results.  The complete example from this page can be found here.","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"The first step is to bring the Clarabel solver and other required packages into scope in your code using:","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"import clarabel\nimport numpy as np\nfrom scipy import sparse","category":"page"},{"location":"python/getting_started_py/#Problem-Format","page":"Getting Started","title":"Problem Format","text":"","category":"section"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_problem.md\",\n  plaintext = true)","category":"page"},{"location":"python/getting_started_py/#Objective-Function","page":"Getting Started","title":"Objective Function","text":"","category":"section"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_objective.md\",\n  plaintext = true)","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"The Clarabel default implementation in Python expects matrix data in Compressed Sparse Column format as produced by scipy.   We can define our cost data as","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"P = sparse.csc_matrix(\n        [[ 3., 1., -1.],\n         [ 1., 4.,  2.],\n         [-1., 2.,  5.]])\n\nP = sparse.triu(P).tocsc()\n\nq = np.array([1., 2., -3.])\n\n","category":"page"},{"location":"python/getting_started_py/#Constraints","page":"Getting Started","title":"Constraints","text":"","category":"section"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_constraints.md\",\n  plaintext = true)","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"We can define our constraint data as","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"# equality constraint\nAeq = sparse.csc_matrix([1.,1.,-1])\n\nbeq = np.array([1.])\n\n# equality constraint\nAineq = sparse.csc_matrix(\n        [[0., 1., 0.],\n         [0., 0., 1.]])\n\nbineq = np.array([2.,2.])\n\n# SOC constraint\nAsoc = -sparse.identity(3)\n\nbsoc = np.array([0.,0.,0.])\n\n# Clarabel constraint data\nA = sparse.vstack([Aeq,Aineq,Asoc]).tocsc()\n\nb = np.concatenate([beq,bineq,bsoc])","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"Clarabel expects to receive a vector of cone specifications.  For the above constraints we should also define","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"cones = [clarabel.ZeroConeT(1),\n         clarabel.NonnegativeConeT(2),\n         clarabel.SecondOrderConeT(3)]","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"There is no restriction on the ordering of the cones that appear in cones, nor on the number of instances of each type that appear. Your input vector b should be compatible with the sum of the cone dimensions.","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_constraints_note.md\",\n  plaintext = true)","category":"page"},{"location":"python/getting_started_py/#Solver-Settings","page":"Getting Started","title":"Solver Settings","text":"","category":"section"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"Solver settings for the Clarabel's default implementation in Rust are stored in a PyDefaultSettings object and can be modified by the user. To create a settings object using all defaults you can call the constructor directly:","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"settings = clarabel.DefaultSettings()","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"If you want to disable verbose printing and set a 5 second time limit on the solver, you can then just modify the fields:","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"settings.verbose = False\nsettings.time_limit = 5.","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"The Clarabel Python interface set supports the same options as those listed in the Rust API Reference.","category":"page"},{"location":"python/getting_started_py/#Making-a-Solver","page":"Getting Started","title":"Making a Solver","text":"","category":"section"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"Finally, populate the solver with problem data and solve:","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"solver = clarabel.DefaultSolver(P,q,A,b,cones,settings)\n\nsolution = solver.solve()\nsolution.x  # primal solution\nsolution.z  # dual solution\nsolution.s  # primal slacks","category":"page"},{"location":"python/getting_started_py/#Results","page":"Getting Started","title":"Results","text":"","category":"section"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"The outcome of the solve is specified in solver.solution.status and will be one of the following :","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"Status Code Description\nUnsolved Default value, only occurs prior to calling solve\nSolved Solution found\nPrimalInfeasible Problem is primal infeasible\nDualInfeasible Problem is dual infeasible\nAlmostSolved Solution found (reduced accuracy)\nAlmostPrimalInfeasible Problem is primal infeasible (reduced accuracy)\nAlmostDualInfeasible Problem is dual infeasible (reduced accuracy)\nMaxIterations Solver halted after reaching iteration limit\nMaxTime Solver halted after reaching time limit\nNumericalError Solver terminated with a numerical error\nInsufficientProgress Solver terminated due to lack of progress","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"The total solution time is available in solution.solve_time.  ","category":"page"},{"location":"python/getting_started_py/#CVXPY-Interface","page":"Getting Started","title":"CVXPY Interface","text":"","category":"section"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"The same problem above can also be modelled in CVXPY and solved via Clarabel.","category":"page"},{"location":"python/getting_started_py/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/py/example_intro_cvxpy.py\",\n  language = :python)","category":"page"},{"location":"examples/example_expcone/#Exponential-Cone-Example","page":"Problem Description","title":"Exponential Cone Example","text":"","category":"section"},{"location":"examples/example_expcone/","page":"Problem Description","title":"Problem Description","text":"In this example we show how to model optimization problems with exponential cone constraints.   The exponential cone is defined as ","category":"page"},{"location":"examples/example_expcone/","page":"Problem Description","title":"Problem Description","text":"beginaligned\nmathcalK_exp = (x y z) mid y geq 0 ye^xy le z cup \n  (xyz) mid   x leq 0 y = 0 z geq 0 \nendaligned","category":"page"},{"location":"examples/example_expcone/","page":"Problem Description","title":"Problem Description","text":"We will solve the following optimization problem:","category":"page"},{"location":"examples/example_expcone/","page":"Problem Description","title":"Problem Description","text":"beginarrayll textmaximize x2ex\ntextsubject to   \nbeginarrayrl\ny e^x  y lez  \ny =1 \nz =e^5\nendarray\nendarray","category":"page"},{"location":"examples/example_expcone/#Objective-function","page":"Problem Description","title":"Objective function","text":"","category":"section"},{"location":"examples/example_expcone/","page":"Problem Description","title":"Problem Description","text":"The Clarabel solver's default configuration expects problems to be posed as minimization problems, so we define:","category":"page"},{"location":"examples/example_expcone/","page":"Problem Description","title":"Problem Description","text":"P = 0\ntextrmand\nq = -\nbeginbmatrix 1  0  0\nendbmatrix^T","category":"page"},{"location":"examples/example_expcone/#Constraints","page":"Problem Description","title":"Constraints","text":"","category":"section"},{"location":"examples/example_expcone/","page":"Problem Description","title":"Problem Description","text":"The solver's default configuration expects constraints in the form Ax + s = b, where s is in a cone or composition of cones.   In this case we can write ","category":"page"},{"location":"examples/example_expcone/","page":"Problem Description","title":"Problem Description","text":"beginbmatrix 0  0  0\nendbmatrix\n - I\nbeginbmatrix x  y  z \nendbmatrix = s\nin mathcalK_exp","category":"page"},{"location":"examples/example_expcone/","page":"Problem Description","title":"Problem Description","text":"and then append the two additional equality constraints.","category":"page"},{"location":"examples/py/example_intro/#python_example_intro_complete","page":"Python \"Getting Started\" complete example","title":"Python \"Getting Started\" complete example","text":"","category":"section"},{"location":"examples/py/example_intro/","page":"Python \"Getting Started\" complete example","title":"Python \"Getting Started\" complete example","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/py/example_intro.py\",\n  language = :python)","category":"page"},{"location":"examples/py/example_sdp/","page":"Python","title":"Python","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/py/example_sdp.py\",\n  language = :python)","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"EditURL = \"../arbitrary_precision.jl\"","category":"page"},{"location":"literate/build/arbitrary_precision/#Arbitrary-Precision-Arithmetic","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"","category":"section"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.jl supports the use of arbitrary precision floating-point types, including Julia's BigFloat type.  To use this feature you must specify all of your problem data using a common floating point type and explictly create Clarabel.Solver and (optional) Clarabel.Settings objects of the the same type.","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Start by creating the solver and settings with the desired precision:","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"using Clarabel, LinearAlgebra, SparseArrays\n\nsettings = Clarabel.Settings{BigFloat}(\n            verbose = true,\n            direct_kkt_solver = true,\n            direct_solve_method = :qdldl)\n\nsolver   = Clarabel.Solver{BigFloat}()","category":"page"},{"location":"literate/build/arbitrary_precision/#Objective-and-constraint-data","page":"Arbitrary Precision Arithmetic","title":"Objective and constraint data","text":"","category":"section"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"We next put the objective function into the standard Clarabel.jl form.   Here we use the same problem data as in the QP Example, but in BigFloat format :","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"P = sparse(BigFloat[3. 0.;0. 2.].*2)\nq = BigFloat[-1., -4.]\nA = sparse(\n    BigFloat[1. -2.;    #<-- LHS of equality constraint\n             1.  0.;    #<-- LHS of inequality constraint (upper bound)\n             0.  1.;    #<-- LHS of inequality constraint (upper bound)\n            -1.  0.;    #<-- LHS of inequality constraint (lower bound)\n             0. -1.;    #<-- LHS of inequality constraint (lower bound)\n    ])\nb = [zero(BigFloat);    #<-- RHS of equality constraint\n     ones(BigFloat,4)   #<-- RHS of inequality constraints\n    ]\n\ncones =\n    [Clarabel.ZeroConeT(1),           #<--- for the equality constraint\n     Clarabel.NonnegativeConeT(4)]    #<--- for the inequality constraints\n\nnothing  #hide","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"You can optionally set the global precision of Julia's BigFloat type before solving","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"setprecision(BigFloat,128)\nnothing  #hide","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Finally we can set up the problem in the usual way and solve","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.setup!(solver, P, q, A, b, cones, settings)\nresult = Clarabel.solve!(solver)\n\n#then retrieve the solution\n\nresult.x","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Notice that the above would fail if the default solver was used, because Clarabel.jl uses Float64 by default","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.Solver()","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"warning: Warning\nFor arbitrary precision arithmetic using BigFloat types you must select an internal linear solver within Clarabel.jl that supports it.   We recommend that you use the QDLDL.jl package for such problems, and configure it as the linear solver by setting both direct_kkt_solver = true and direct_solve_method = :qdldl in the Settings object.","category":"page"},{"location":"literate/build/arbitrary_precision/#With-Convex.jl-/-JuMP","page":"Arbitrary Precision Arithmetic","title":"With Convex.jl / JuMP","text":"","category":"section"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"Clarabel.jl also supports arbitrary precision arithmetic through Convex.jl.   See the example in the Convex.jl Interface section.","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"note: Note\nJuMP does not currently support arbitrary precision. However, if you want to use Clarabel directly with MathOptInterface, you can use: Clarabel.Optimizer{<: AbstractFloat} as your optimizer.  As above, the problem data precision of your MathOptInterface-model must agree with the optimizer's precision.","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"","category":"page"},{"location":"literate/build/arbitrary_precision/","page":"Arbitrary Precision Arithmetic","title":"Arbitrary Precision Arithmetic","text":"This page was generated using Literate.jl.","category":"page"},{"location":"_common/getting_started_constraints_note/","page":"-","title":"-","text":"note: Note\nNote carefully the signs in the above example.   The inequality condition is A_ineq x le b_ineq, which is equivalent to A_ineq x + s = b_ineq with s ge 0, i.e. s in the Nonnegative cone.    The SOC condition is x in mathcalK_SOC, or equivalently -x + s = 0 with s in mathcalK_SOC.","category":"page"},{"location":"user_guide_c_cpp/#user-guide-r","page":"C/C++","title":"C/C++ Installation and User Guide","text":"","category":"section"},{"location":"user_guide_c_cpp/","page":"C/C++","title":"C/C++","text":"C and C++ interfaces to Clarabel can be found here.","category":"page"},{"location":"user_guide_c_cpp/","page":"C/C++","title":"C/C++","text":"The C++ version accepts solver inputs in the form of Eigen matrices and vectors. ","category":"page"},{"location":"examples/example_powcone/#Power-Cone-Example","page":"Problem Description","title":"Power Cone Example","text":"","category":"section"},{"location":"examples/example_powcone/","page":"Problem Description","title":"Problem Description","text":"In this example we show how to model optimization problems with 3-dimensional power cone constraints.   The power cone is defined as ","category":"page"},{"location":"examples/example_powcone/","page":"Problem Description","title":"Problem Description","text":"mathcalK_pow(alpha) = (x y z) mid x^alpha y^(1-alpha) \ngeq  z (xy) geq 0  ","category":"page"},{"location":"examples/example_powcone/","page":"Problem Description","title":"Problem Description","text":"with alpha in (01).","category":"page"},{"location":"examples/example_powcone/","page":"Problem Description","title":"Problem Description","text":"We will solve the following optimization problem:","category":"page"},{"location":"examples/example_powcone/","page":"Problem Description","title":"Problem Description","text":"beginarrayll textmaximize  x_1^06 y^04 + x_2^012ex\ntextsubject to   \nbeginarrayrl\n(x_1 y x_2) ge 0 \nx_1 + 2y  + 3x_2 = 3\nendarray\nendarray","category":"page"},{"location":"examples/example_powcone/","page":"Problem Description","title":"Problem Description","text":"which is equivalent to","category":"page"},{"location":"examples/example_powcone/","page":"Problem Description","title":"Problem Description","text":"beginarrayll textmaximize  z_1 + z_22ex\ntextsubject to   \nbeginarrayrl\n(x1 y z1) inmathcalK_pow(06) \n(x2 1 z2) inmathcalK_pow(01)  \nx_1 + 2y  + 3x_2 =3\nendarray\nendarray","category":"page"},{"location":"examples/py/example_powcone/","page":"Python","title":"Python","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/py/example_powcone.py\",\n  language = :python)","category":"page"},{"location":"julia/linear_solvers/#Linear-System-Solvers","page":"Linear Solvers","title":"Linear System Solvers","text":"","category":"section"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"The primary numerical operation inside Clarabel.jl is the solution of a symmetric quasidefinite linear system at each iteration.  The solver currently supports three different solvers to perform factorization and forward/backward substitution on this system.","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"The linear solver can be configured in Settings using the direct_solve_method field, e.g.","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"settings = Solver.Settings(direct_solve_method = :qdldl)","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"The solvers currently supported are","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"Symbol Package Description\n:qdldl QDLDL.jl Default solver\n:mkl Pardiso.jl Intel MKL Pardiso\n:panua Pardiso.jl Panua Pardiso\n:ma57 HSL.jl HSL MA57\n:cholmod Julia native ldlt solver SuiteSparse.CHOLMOD","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"note: Note\nTo use the Pardiso solvers you must install the respective libraries and the corresponding Julia wrapper. For more information about installing these, visit the Pardiso.jl repository page.   You must also bring Pardiso into scope first (i.e. using Pardiso) before solving. The same is true for the HSL MA57 solver, which requires the HSL library and the Julia wrapper [HSL.jl].","category":"page"},{"location":"julia/linear_solvers/","page":"Linear Solvers","title":"Linear Solvers","text":"QDLDL is a single threaded solver written in pure Julia, and is generally adequate for problems of small to medium size.  ","category":"page"},{"location":"examples/example_sdp/#Semidefinite-Program-(SDP)-Example","page":"Problem Description","title":"Semidefinite Program (SDP) Example","text":"","category":"section"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"In this example we show how to model semidefinite programming problems, i.e. problems defined with constraints on the symmetric positive semidefinite cone.","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"Given some symmetric matrix X in mathbbR^ntimes n, Clarabel takes only the upper triangular vector of n(n+1)2 entries when imposing semidefinite constraints.   For example, given a 3 times 3 symmetric matrix variable  ","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"X = beginbmatrix\nx_1  x_2  x_4  \nx_2  x_3  x_5  \nx_4  x_5  x_6\nendbmatrix","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"we would take as our decision variable the 6 element vector ","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"x = \nbeginbmatrix\nx_1  x_2  x_3  x_4  x_5  x_6\nendbmatrix","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"We define an operation ","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"textrmvec(X) = \nbeginbmatrix\nx_1  sqrt2x_2  x_3  sqrt2x_4  sqrt2x_5  x_6\nendbmatrix","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"on symmetric matrices such that inner products are preserved, i.e. textrmtr(AB) =  textrmvec(A)^Ttextrmvec(B), and will use the relationship ","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"S in mathbbR^n quad Longleftrightarrow quad textrmvec(S) in mathcalK_texttri^n","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"where mathcalK_texttri^n is the positive semidefinite triangle cone.","category":"page"},{"location":"examples/example_sdp/#Problem-statement","page":"Problem Description","title":"Problem statement","text":"","category":"section"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"We will solve the following optimization problem:","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"beginarrayll textminimize textrmtrace(X)2ex\ntextsubject to   \nbegingathered\nlangle AXrangle = 1 \nX succeq 0\nendgathered\nendarray","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"where X = X^T inmathbbR^3times 3 and the symmetric matrix A is defined as ","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"A = beginbmatrix\n1  2  4  \n2  3  5  \n4  5  6\nendbmatrix","category":"page"},{"location":"examples/example_sdp/#Objective-function","page":"Problem Description","title":"Objective function","text":"","category":"section"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"We can model the trace of the matrix X by defining our objective function as ","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"frac12x^TPx + q^Tx  ","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"with P = 0 and  q = beginbmatrix 1  0  1  0  0  1 endbmatrix^T, where the elements of q are chosen to select those elements of x corresonding to the diagonal of the matrix X.  ","category":"page"},{"location":"examples/example_sdp/#Constraints","page":"Problem Description","title":"Constraints","text":"","category":"section"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"The solver's default configuration expects constraints in the form Ax + s = b.   In this we can write our semidefiniteness constraint as ","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"-textvec(X) = s in mathcalK_texttri^n","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"where mathcalK_texttri^n is the cone of vectors representing the triangular part of matrices in mathbbS_+^n.","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"For the equality constraint can we must be careful to rewrite the inner product on X in a form that is an equivalent linear function of x.  We therefore write ","category":"page"},{"location":"examples/example_sdp/","page":"Problem Description","title":"Problem Description","text":"beginaligned\n  langle AXrangle = textrmvec(A)^Ttextrmvec(X) \n  = beginbmatrix\n1  (2cdot 2)  3  (2cdot 4)  (2cdot 5)  6\nendbmatrix\nbeginbmatrix\nx_1  x_2  x_3  x_4  x_5  x_6\nendbmatrix = 1\nendaligned","category":"page"},{"location":"examples/example_socp/#SOCP-Example","page":"Problem Description","title":"SOCP Example","text":"","category":"section"},{"location":"examples/example_socp/","page":"Problem Description","title":"Problem Description","text":"Suppose that we want to solve the following 2-dimensional optimization problem:","category":"page"},{"location":"examples/example_socp/","page":"Problem Description","title":"Problem Description","text":"beginarrayll textminimize  x_2^22ex\ntextsubject to   leftbeginpmatrix 2x_1  x_2 endpmatrix\n- beginpmatrix 2  2 endpmatrixright_2 le 1\nendarray","category":"page"},{"location":"examples/example_socp/","page":"Problem Description","title":"Problem Description","text":"We will show how to solve this problem through each of Clarabel's supported languages and interfaces.","category":"page"},{"location":"examples/example_socp/#Objective-function","page":"Problem Description","title":"Objective function","text":"","category":"section"},{"location":"examples/example_socp/","page":"Problem Description","title":"Problem Description","text":"The Clarabel solver's default configuration expects problem data in the form frac12x^top P x + q^top x.    We therefore define the objective function data as","category":"page"},{"location":"examples/example_socp/","page":"Problem Description","title":"Problem Description","text":"P = 2 cdot beginbmatrix 0  0  0  1endbmatrix\ntextrmand\nq = beginbmatrix 0  0endbmatrix","category":"page"},{"location":"examples/example_socp/#Constraints","page":"Problem Description","title":"Constraints","text":"","category":"section"},{"location":"examples/example_socp/","page":"Problem Description","title":"Problem Description","text":"The solver's default configuration expects constraints in the form Ax + s = b, where s in mathcalK for some composite cone mathcalK.   We have a single constraint on the 2-norm of a vector, so we rewrite","category":"page"},{"location":"examples/example_socp/","page":"Problem Description","title":"Problem Description","text":"leftbeginpmatrix 2x_1  x_2 endpmatrix - beginpmatrix 2  2 endpmatrixright_2 le 1\nquad Longleftrightarrow quad\nbeginpmatrix 1  2x_1 - 2 x_2 - 2 endpmatrix in mathcalK_SOC","category":"page"},{"location":"examples/example_socp/","page":"Problem Description","title":"Problem Description","text":"which puts our constraint in the form b - Ax in mathcalK_SOC.   ","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"EditURL = \"../../../../examples/jl/example_intro.jl\"","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"This code implements the example in the Clarabel \"Getting Started\" documentation","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"using Clarabel, SparseArrays, LinearAlgebra\n\nP = sparse([3. 1 -1; 0 4 2; 0 0 5])\n\nq = [1,2,-3.]","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"equality constraint","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"Aeq = [1. 1. -1.]\nbeq = [1.]","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"inequality constraint","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"Aineq = [0. 1. 0.;\n         0. 0. 1.]\nbineq = [2.,2.]","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"SOC constraint","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"Asoc = -I(3)*1.\nbsoc = [0.,0.,0.]","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"Clarabel.jl constraint data","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"A = sparse([Aeq; Aineq; Asoc])\nb = [beq;bineq;bsoc]\n\ncones = [Clarabel.ZeroConeT(1),\n         Clarabel.NonnegativeConeT(2),\n         Clarabel.SecondOrderConeT(3)]\n\nsettings = Clarabel.Settings(verbose = true, time_limit = 5)\n\nsolver   = Clarabel.Solver()\n\nClarabel.setup!(solver, P, q, A, b, cones, settings)\n\nsolution = Clarabel.solve!(solver)","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"","category":"page"},{"location":"examples/jl/example_intro/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"rust/getting_started_rs/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"This section describes the process of creating a Clarabel.rs model, populating its settings and problem data, solving the problem and obtaining and understanding results.  It is assumed here that you are building your project using cargo.","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"Full documentation for the Rust API is available in the API Reference.","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"The first step is to make the Clarabel solver a dependency in your project by adding:","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"[dependencies]\nclarabel = {version = \"0\"}","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"to your project's Cargo.toml file.    Then bring the solver into scope in your source files:","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"use clarabel::algebra::*;\nuse clarabel::solver::*;","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"The algebra module defines the CscMatrix type for defining matrices in compressed sparse column format.   It also contains some basic utilities for creating and manipulating sparse matrices.","category":"page"},{"location":"rust/getting_started_rs/#Problem-Format","page":"Getting Started","title":"Problem Format","text":"","category":"section"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_problem.md\",\n  plaintext = true)","category":"page"},{"location":"rust/getting_started_rs/#Objective-Function","page":"Getting Started","title":"Objective Function","text":"","category":"section"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_objective.md\",\n  plaintext = true)","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"The Clarabel default implementation in Rust expects matrix data as a CscMatrix object and provides a set of basic utilities for sparse matrix construction.   We can define our cost data as","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"let P = CscMatrix::new(\n    3,                             // m\n    3,                             // n\n    vec![0, 1, 3, 6],              // colptr\n    vec![0, 0, 1, 0, 1, 2],        // rowval\n    vec![3., 1., 4., -1., 2., 5.], // nzval\n);\n\nlet q = vec![1., 2., -3.];","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nTo specify P = I, you can uselet P = CscMatrix::identity(2);where in this case we have had to be specific about the floating point data type we want.   To use a zero matrix (e.g. if solving an LP), you can uselet P = CscMatrix::spalloc((2,2),0);to construct a sparse matrix with no entries.The solver will not conduct any check on the internal correctness of matrices  passed in CscMatrix format.   You can do this externally using the check_format method, e.g.:assert!(P.check_format().is_ok());","category":"page"},{"location":"rust/getting_started_rs/#Constraints","page":"Getting Started","title":"Constraints","text":"","category":"section"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_constraints.md\",\n  plaintext = true)","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"We can define our constraint data as","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"let Aeq = CscMatrix::new(\n        1,                 // m\n        3,                 // n\n        vec![0, 1, 2, 3],  // colptr\n        vec![0, 0, 0],     // rowval\n        vec![1., 1., -1.], // nzval\n    );\n\n    let Aineq = CscMatrix::new(\n        2,                // m\n        3,                // n\n        vec![0, 0, 1, 2], // colptr\n        vec![0, 1],       // rowval\n        vec![1., 1.],     // nzval\n    );\n\n    let mut Asoc = CscMatrix::identity(3);\n    Asoc.negate();\n\n    let A = CscMatrix::vcat(&Aeq, &Aineq);\n    let A = CscMatrix::vcat(&A, &Asoc);\n\n    let b = vec![1., 2., 2., 0., 0., 0.];\n\n    // optional correctness check \n    assert!(A.check_format().is_ok());","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"Clarabel.rs expects to receive a vector of cone specifications.  For the above constraints we should also define","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"# Clarabel.jl cone specification\nlet cones = [ZeroConeT(1), NonnegativeConeT(2), SecondOrderConeT(3)];","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"There is no restriction on the ordering of the cones that appear in cones, nor on the number of instances of each type that appear. Your input vector b should be compatible with the sum of the cone dimensions.","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_constraints_note.md\",\n  plaintext = true)","category":"page"},{"location":"rust/getting_started_rs/#Solver-Settings","page":"Getting Started","title":"Solver Settings","text":"","category":"section"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"Solver settings for the Clarabel's default implementation in Rust are stored in a DefaultSettings object and can be modified by the user. To create a settings object using all defaults you can call the constructor directly:","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"let settings = DefaultSettings::default();","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"Alternatively, you can use the DefaultSettingsBuilder to specify custom settings.   For example, if you want to disable verbose printing and set a 5 second time limit on the solver, you can use:","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"let settings = DefaultSettingsBuilder::default()\n    .verbose(false)\n    .time_limit(1.)\n    .build()\n    .unwrap();","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"The full set of user configurable solver settings are listed in the Rust API Reference.","category":"page"},{"location":"rust/getting_started_rs/#Making-a-Solver","page":"Getting Started","title":"Making a Solver","text":"","category":"section"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"Finally populate the solver with problem data and solve:","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"let mut solver = DefaultSolver::new(&P, &q, &A, &b, &cones, settings);\n\nsolver.solve();","category":"page"},{"location":"rust/getting_started_rs/#Results","page":"Getting Started","title":"Results","text":"","category":"section"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"Once the solver algorithm terminates you can inspect the solution using the solution field of the solver.  ","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"println!(\"Solution status = {:?}\", solver.solution.status);\nprintln!(\"Primal solution = {:?}\", solver.solution.x);\nprintln!(\"Dual solution   = {:?}\", solver.solution.z);\nprintln!(\"Primal slacks   = {:?}\", solver.solution.s);","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"The outcome of the solve is specified in solver.solution.status and will be one of the following :","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"Status Code Description\nUnsolved Default value, only occurs prior to calling solve\nSolved Solution found\nPrimalInfeasible Problem is primal infeasible\nDualInfeasible Problem is dual infeasible\nAlmostSolved Solution found (reduced accuracy)\nAlmostPrimalInfeasible Problem is primal infeasible (reduced accuracy)\nAlmostDualInfeasible Problem is dual infeasible (reduced accuracy)\nMaxIterations Solver halted after reaching iteration limit\nMaxTime Solver halted after reaching time limit\nNumericalError Solver terminated with a numerical error\nInsufficientProgress Solver terminated due to lack of progress","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"The total solution time is available in solver.solution.solve_time.  ","category":"page"},{"location":"rust/getting_started_rs/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_solution_warn.md\",\n  plaintext = true)","category":"page"},{"location":"julia/getting_started_jl/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"This section describes the process of creating a Clarabel.jl model, populating its settings and problem data, solving the problem and obtaining and understanding results.  The description here relates to Clarabel's native API.  ","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"The first step is to bring the Clarabel solver and other required packages into scope in your code using:","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"using Clarabel, SparseArrays, LinearAlgebra","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"The SparseArrays package from the Julia standard distribution defines the SparseMatrixCSC type for defining matrices in compressed sparse column format.  ","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"JuMP / Convex.jl support: We provide an interface to MathOptInterface (MOI), which allows you to describe your problem in JuMP and Convex.jl.  If you want to use JuMP or Convex.jl to model your  problem instead, see the JuMP Interface and Convex.jl Interface sections.","category":"page"},{"location":"julia/getting_started_jl/#Problem-Format","page":"Getting Started","title":"Problem Format","text":"","category":"section"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_problem.md\",\n  plaintext = true)","category":"page"},{"location":"julia/getting_started_jl/#Objective-Function","page":"Getting Started","title":"Objective Function","text":"","category":"section"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_objective.md\",\n  plaintext = true)","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"The Clarabel default implementation in Julia expects matrix data in sparse SparseMatrixCSC format.  We can define our cost data as","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"P = sparse([3. 1 -1; 0 4 2; 0 0 5])\nq = [1,2,-3.]","category":"page"},{"location":"julia/getting_started_jl/#Constraints","page":"Getting Started","title":"Constraints","text":"","category":"section"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_constraints.md\",\n  plaintext = true)","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"We can then define our constraint data as","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"using SparseArrays\n\n# equality constraint\nAeq = [1. 1. -1.]\nbeq = [1.]\n\n# inequality constraint\nAineq = [0. 1. 0.;\n         0. 0. 1.]\nbineq = [2.,2.]\n\n# SOC constraint\nAsoc = -I(3)*1.\nbsoc = [0.,0.,0.]\n\n# Clarabel.jl constraint data\nA = sparse([Aeq; Aineq; Asoc])\nb = [beq;bineq;bsoc]","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"Clarabel.jl expects to receive a vector of cone specifications.  For the above constraints we  should also define","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"# Clarabel.jl cone specification\ncones = [Clarabel.ZeroConeT(1), Clarabel.NonnegativeConeT(2), Clarabel.SecondOrderConeT(3)]","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"There is no restriction on the ordering of the cones that appear in cones, nor on the number of instances of each type that appear.  The cones should be of type Vector{Clarabel.SupportedCone}, and your input vector b should be compatible with the sum of the cone dimensions.","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_constraints_note.md\",\n  plaintext = true)","category":"page"},{"location":"julia/getting_started_jl/#Solver-Settings","page":"Getting Started","title":"Solver Settings","text":"","category":"section"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"Solver settings are stored in a Settings object and can be modified by the user. To create a Settings object just call the constructor:","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"settings = Clarabel.Settings()","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"To adjust those values, you can pass options and parameters as a key-value pair to the constructor or edit the corresponding field afterwards. For example, if you want to disable verbose printing and set a 5 second time limit on the solver, you can use","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"settings = Clarabel.Settings(verbose = false, time_limit = 5)\n\n# the following is equivalent\nsettings = Clarabel.Settings()\nsettings.verbose    = false\nsettings.time_limit = 5","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"The full set of user configurable solver settings are listed in the API Reference.","category":"page"},{"location":"julia/getting_started_jl/#Making-a-Solver","page":"Getting Started","title":"Making a Solver","text":"","category":"section"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"The problem data, user settings and workspace variables are all stored in a top level Solver type. First define an empty Solver:","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"solver  = Clarabel.Solver()","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"Then provide the solver with problem data using","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"Clarabel.setup!(solver, P, q, A, b, cones, settings)","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"This takes an internal copy of all data parameters and initializes internal variables and other objects in the solver.  The final settings argument is optional.","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"Now you can solve your problem using:","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"solution = Clarabel.solve!(solver)\nsolution.x   # primal solution\nsolution.z   # dual solution\nsolution.s   # slacks","category":"page"},{"location":"julia/getting_started_jl/#Results","page":"Getting Started","title":"Results","text":"","category":"section"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"Once the solver algorithm terminates you can inspect the solution using the solution object.  The outcome of the solve is specified in solution.status and will be one of the following :","category":"page"},{"location":"julia/getting_started_jl/#Status-Codes","page":"Getting Started","title":"Status Codes","text":"","category":"section"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"Status Code Description\nSOLVED Solver terminated with a solution.\nPRIMAL_INFEASIBLE Problem is primal infeasible.  Solution returned is a certificate of primal infeasibility.\nDUAL_INFEASIBLE Problem is dual infeasible.  Solution returned is a certificate of dual infeasibility.\nALMOST_SOLVED Solver terminated with a solution (reduced accuracy).\nALMOST_PRIMAL_INFEASIBLE Problem is primal infeasible.  Solution returned is a certificate of primal infeasibility (reduced accuracy).\nALMOST_DUAL_INFEASIBLE Problem is dual infeasible.  Solution returned is a certificate of dual infeasibility (reduced accuracy).\nMAX_ITERATIONS Iteration limit reached before solution or infeasibility certificate found.\nMAX_TIME Time limit reached before solution or infeasibility certificate found.\nNUMERICAL_ERROR Solver terminated with a numerical error.\nINSUFFICIENT_PROGRESS Solver terminated due to lack of progress.","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"The total solution time (include combined setup! and solve! times) is given in solution.solve_time.   Detailed information about the solve time and memory allocation can be found in the solver's timer field.","category":"page"},{"location":"julia/getting_started_jl/","page":"Getting Started","title":"Getting Started","text":"using Documenter\nDocumenter.md_include(\n  source = \"docs/src/_common/getting_started_solution_warn.md\",\n  plaintext = true)","category":"page"},{"location":"julia/jump/#JuMP-Interface","page":"JuMP Interface","title":"JuMP Interface","text":"","category":"section"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"Clarabel.jl implements support for MathOptInterface, and is therefore compatible with JuMP.   This allows you to describe and modify your optimisation problem with JuMP and use Clarabel.jl as the backend solver.","category":"page"},{"location":"julia/jump/#Setting-Clarabel.jl-Backend","page":"JuMP Interface","title":"Setting Clarabel.jl Backend","text":"","category":"section"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"To specify Clarabel.jl as the solver for your JuMP model, load the solver module with using Clarabel and then configure Clarabel as the solver backend when initialising the JuMP model:","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"model = JuMP.Model(Clarabel.Optimizer)","category":"page"},{"location":"julia/jump/#Solver-Settings","page":"JuMP Interface","title":"Solver Settings","text":"","category":"section"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"Solver-specific settings can be passed after the Clarabel.Optimizer object. For example, if you want to adjust the maximum number of iterations and turn off verbose printing use","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"set_optimizer_attribute(model, \"verbose\", true)\nset_optimizer_attribute(model, \"max_iter\", 25)","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"The full list of available settings can be found in the Settings section of the API Reference.","category":"page"},{"location":"julia/jump/#Results","page":"JuMP Interface","title":"Results","text":"","category":"section"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"After solving the problem the result can be obtained using the standard JuMP commands. To see if the optimisation was successful use","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"JuMP.termination_status(model)\nJuMP.primal_status(model)","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"If a solution is available, the optimal objective value can be retrieved using","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"JuMP.objective_value(model)","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"and the value of a decision variable x can be obtained with","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"JuMP.value.(x)","category":"page"},{"location":"julia/jump/","page":"JuMP Interface","title":"JuMP Interface","text":"For more information on JuMP, see the JuMP documentation.","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"EditURL = \"../../../../examples/jl/example_qp.jl\"","category":"page"},{"location":"examples/jl/example_qp/#Quadratic-Program-(QP)-Example-in-Julia","page":"Julia","title":"Quadratic Program (QP) Example in Julia","text":"","category":"section"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"We will show how to solve the Basic QP example problem both natively in Clarabel.jl and also by solving with Clarabel.jl within either JuMP or Convex.jl.","category":"page"},{"location":"examples/jl/example_qp/#Clarabel.jl-native-interface","page":"Julia","title":"Clarabel.jl native interface","text":"","category":"section"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"using Clarabel, SparseArrays\n\nP = sparse([3. 0.;0. 2.].*2)\n\nq = [-1., -4.]\n\nA = sparse([1. -2.;    #<-- LHS of equality constraint\n            1.  0.;    #<-- LHS of inequality constraint (upper bound)\n            0.  1.;    #<-- LHS of inequality constraint (upper bound)\n           -1.  0.;    #<-- LHS of inequality constraint (lower bound)\n            0. -1.;    #<-- LHS of inequality constraint (lower bound)\n            ])\n\nb = [0.;        #<-- RHS of equality constraint\n     ones(4)]   #<-- RHS of inequality constraints\n\ncones =\n    [Clarabel.ZeroConeT(1),           #<--- for the equality constraint\n     Clarabel.NonnegativeConeT(4)]    #<--- for the inequality constraints\n\nsettings = Clarabel.Settings()\n\nsolver   = Clarabel.Solver()\n\nClarabel.setup!(solver, P, q, A, b, cones, settings)\n\nresult = Clarabel.solve!(solver)\n\nnothing #hide","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"result #hide","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"result.x","category":"page"},{"location":"examples/jl/example_qp/#Using-JuMP","page":"Julia","title":"Using JuMP","text":"","category":"section"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"We can solve the same problem a little more easily by using Clarabel.jl as the backend solver within JuMP. Here is the same problem again:","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"using Clarabel, JuMP\n\nmodel = JuMP.Model(Clarabel.Optimizer)\nset_optimizer_attribute(model, \"verbose\", true)\n\n@variable(model, x[1:2])\n@constraint(model, x[1] == 2x[2])\n@constraint(model,  -1 .<= x .<= 1)\n@objective(model, Min, 3x[1]^2 + 2x[2]^2 - x[1] - 4x[2])\n\noptimize!(model)","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"Here is the solution","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"JuMP.value.(x)","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"and the solver termination status again","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"JuMP.termination_status(model)","category":"page"},{"location":"examples/jl/example_qp/#Using-Convex.jl","page":"Julia","title":"Using Convex.jl","text":"","category":"section"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"We can likewise solve the same problem a using Clarabel.jl as the backend solver within Convex.jl.   Here is the same problem one more time:","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"using Clarabel, Convex\n\nx = Variable(2)\nproblem = minimize(3square(x[1]) + 2square(x[2]) - x[1] - 4x[2])\nproblem.constraints = [x[1] == 2x[2]]\nproblem.constraints += [x >= -1; x <= 1]\nsolve!(problem, Clarabel.Optimizer; silent_solver = false)","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"Here is our solution","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"evaluate(x)","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"and the solver termination status again","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"problem.status","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"warning: Warning\nNote that in the Clarabel.jl output that follows the call to solve! using Convex.jl, the problem posed to the solver has been converted to a second-order cone program with a linear objective.   You can see this because now nnz(P) == 0 (there is no quadratic term in the objective) and the solver reports two second order cone constraints.Although the solution will be the same, the required number of iterations and solve time are slightly higher.  When solving problems with quadratic objectives in Clarabel.jl, it is generally preferable to use either the  native Clarabel.jl interface or JuMP, both of which handle quadratic terms in the objective directly.","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"","category":"page"},{"location":"examples/jl/example_qp/","page":"Julia","title":"Julia","text":"This page was generated using Literate.jl.","category":"page"},{"location":"_common/getting_started_problem/","page":"-","title":"-","text":"Clarabel solves optimisation problems in the format:","category":"page"},{"location":"_common/getting_started_problem/","page":"-","title":"-","text":"beginarrayll textminimize  textstylefrac12x^top Px + q^top x textsubject to  Ax + s = b   s in mathcalK endarray","category":"page"},{"location":"_common/getting_started_problem/","page":"-","title":"-","text":"with decision variables x in mathbbR^n, s in mathbbR^m and data matrices P=P^top succeq 0, q in mathbbR^n, A in mathbbR^m times n, and b in mathbbR^m.  The convex cone mathcalK is a composition of smaller convex cones mathcalK = mathcalK_1 times mathcalK_2  dots mathcalK_p.   Equality conditions can be modelled in this format using the solver's ZeroCone type.  ","category":"page"},{"location":"_common/getting_started_problem/","page":"-","title":"-","text":"To initialize the solver with an optimisation problem we require three things:","category":"page"},{"location":"_common/getting_started_problem/","page":"-","title":"-","text":"The objective function, i.e. the matrix P and the vector q in frac12x^top P x + q^top x.\nThe data matrix A and vector b, along with a description of the composite cone mathcalK and the dimensions of its constituent pieces.\nA settings object that specifies how Clarabel solves the problem.","category":"page"},{"location":"_common/getting_started_objective/","page":"-","title":"-","text":"To set the objective function of your optimisation problem simply define the square positive semidefinite matrix P in mathrmR^ntimes n and the vector q in mathrmR^n.","category":"page"},{"location":"_common/getting_started_objective/","page":"-","title":"-","text":"Suppose that we have a problem with decision variable x in mathbbR^3 and our objective function is:","category":"page"},{"location":"_common/getting_started_objective/","page":"-","title":"-","text":"beginequation*\nmin \nfrac12\nleft\nbeginarrayl\nx_1  x_2 x_3\nendarray\nright\n^T\nleft\nbeginarrayrrr\n30   10   -10 \n10    40   20 \n -10    20    50\nendarray\nright\nleft\nbeginarrayl\nx_1  x_2 x_3\nendarray\nright\n+\nleft\nbeginarrayr\n1  2 -3\nendarray\nright^T\nleft\nbeginarrayl\nx_1  x_2 x_3\nendarray\nright\nendequation*","category":"page"},{"location":"_common/getting_started_objective/","page":"-","title":"-","text":"Clarabel expects the P matrix to be supplied in Compressed Sparse Column format.  P is assumed by the solver to be symmetric and only values in the upper triangular part of P are needed by the solver, i.e. you only need to provide","category":"page"},{"location":"_common/getting_started_objective/","page":"-","title":"-","text":"beginequation*\nP =\nleft\nbeginarrayrrr\n30   10   -10 \n    40   20 \n        50\nendarray\nright\nendequation*","category":"page"},{"location":"rust/installation_rs/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"rust/installation_rs/#Using-Cargo","page":"Installation","title":"Using Cargo","text":"","category":"section"},{"location":"rust/installation_rs/","page":"Installation","title":"Installation","text":"Clarabel.rs is available through the Rust registry at crates.io and can be imported directly as a dependency in your project.   Just add","category":"page"},{"location":"rust/installation_rs/","page":"Installation","title":"Installation","text":"[dependencies]\nclarabel = \"0\"  ","category":"page"},{"location":"rust/installation_rs/","page":"Installation","title":"Installation","text":"in your project's Cargo.toml file to obtain the latest version.","category":"page"},{"location":"rust/installation_rs/#Direct-from-source","page":"Installation","title":"Direct from source","text":"","category":"section"},{"location":"rust/installation_rs/","page":"Installation","title":"Installation","text":"You can also download and build the repository directly from Github:   ","category":"page"},{"location":"rust/installation_rs/","page":"Installation","title":"Installation","text":"git clone https://github.com/oxfordcontrol/Clarabel.rs\ncd Clarabel.rs\ncargo build --release","category":"page"},{"location":"rust/installation_rs/","page":"Installation","title":"Installation","text":"To check that your installation worked, you can run","category":"page"},{"location":"rust/installation_rs/","page":"Installation","title":"Installation","text":"cargo run --example qp","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clarabel is an interior point numerical solver for convex optimization problems using a novel homogeneous embedding.  The Clarabel package solves the following problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginarrayr\ntextminimize  frac12x^T P x + q^T x2ex\n textsubject to  Ax + s = b 1ex\n         s in mathcalK\n endarray","category":"page"},{"location":"","page":"Home","title":"Home","text":"with decision variables x in mathbbR^n, s in mathbbR^m and data matrices P=P^top succeq 0, q in mathbbR^n, A in mathbbR^m times n, and b in mathbbR^m. The convex set mathcalK is a composition of convex cones.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clarabel is available in either a native Julia or a native Rust implementation. Additional language interfaces (Python, C/C++ and R) are available for the Rust version.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Versatile: Clarabel solves linear programs (LPs), quadratic programs (QPs), second-order cone programs (SOCPs) and semidefinite programs (SDPs). It also solves problems with exponential, power cone and generalized power cone constraints.\nQuadratic objectives: Unlike interior point solvers based on the standard homogeneous self-dual embedding (HSDE) model, Clarabel handles quadratic objective without requiring any epigraphical reformulation of its objective function.   It can therefore be significantly faster than other HSDE-based solvers for problems with quadratic objective functions.\nInfeasibility detection: Infeasible problems are detected using using a homogeneous embedding technique.\nArbitrary precision types: You can solve problems with any floating point precision, e.g. Float32 or Julia's BigFloat type in Julia and f32 or f64 types in Rust.\nOpen Source: Our code is available on GitHub and distributed under the Apache 2.0 License.   The Julia implementation is here.   The Rust implementation and Python interface is here.","category":"page"},{"location":"#Credits","page":"Home","title":"Credits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following people are involved in the development of Clarabel:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Paul Goulart (main development, maths and algorithms)\nYuwen Chen (maths and algorithms)","category":"page"},{"location":"","page":"Home","title":"Home","text":"All contributors are affiliated with the Control Group of the Department of Engineering Science at the University of Oxford.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If this project is useful for your work please consider","category":"page"},{"location":"","page":"Home","title":"Home","text":"Citing the relevant papers\nLeaving a star on the GitHub repository (Julia) : (Rust).","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clarabel.jl and Clarabel.rs are licensed under the Apache License 2.0 (Julia) : (Rust).","category":"page"},{"location":"examples/rs/example_socp/","page":"Rust","title":"Rust","text":"Complete Cargo projects for all Rust examples can be found in examples/rs.","category":"page"},{"location":"examples/rs/example_socp/","page":"Rust","title":"Rust","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/rs/example_socp/src/main.rs\",\n  language = :rust)","category":"page"},{"location":"examples/jl/README/","page":"-","title":"-","text":"Julia examples in this directory are automatically built from the <repo>/examples/jl using the Literate.jl package during documentation build.   ","category":"page"},{"location":"citing/","page":"Citing Clarabel","title":"Citing Clarabel","text":"If you find Clarabel useful in your work, please consider citing one or more of the following papers.  For the solver itself:","category":"page"},{"location":"citing/","page":"Citing Clarabel","title":"Citing Clarabel","text":"@misc{Clarabel_2024,\n      title={Clarabel: An interior-point solver for conic programs with quadratic objectives}, \n      author={Paul J. Goulart and Yuwen Chen},\n      year={2024},\n      eprint={2405.12762},\n      archivePrefix={arXiv},\n      primaryClass={math.OC}\n}","category":"page"},{"location":"citing/","page":"Citing Clarabel","title":"Citing Clarabel","text":"A preprint is available here.","category":"page"},{"location":"citing/","page":"Citing Clarabel","title":"Citing Clarabel","text":"If you use Clarabel to solve SDPs with decomposable structure:","category":"page"},{"location":"citing/","page":"Citing Clarabel","title":"Citing Clarabel","text":"@InProceedings{Garstka_2020,\n  author  = {Michael Garstka and Mark Cannon and Paul Goulart},\n  title   = {A clique graph based merging strategy for decomposable {SDPs}},\n  year    = {2020},\n  note    = {21th IFAC World Congress},\n  number  = {2},\n  pages   = {7355-7361},\n  volume  = {53},\n  doi     = {10.1016/j.ifacol.2020.12.1255},\n  issn    = {2405-8963},\n  journal = {IFAC-PapersOnLine},\n}","category":"page"},{"location":"citing/","page":"Citing Clarabel","title":"Citing Clarabel","text":"A preprint is available here.","category":"page"},{"location":"citing/","page":"Citing Clarabel","title":"Citing Clarabel","text":"If you use Clarabel to solve problems with generalized power cones:","category":"page"},{"location":"citing/","page":"Citing Clarabel","title":"Citing Clarabel","text":"@misc{chen2023efficient,\n      title={An Efficient IPM Implementation for A Class of Nonsymmetric Cones}, \n      author={Yuwen Chen and Paul Goulart},\n      year={2023},\n      eprint={2305.12275},\n      archivePrefix={arXiv},\n      primaryClass={math.OC}\n}","category":"page"},{"location":"citing/","page":"Citing Clarabel","title":"Citing Clarabel","text":"A preprint is available here.","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Contributions are always welcome:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Please report any issues and bugs that you encounter in Issues.\nAs an open source project we are also interested in any projects and applications that use Clarabel. Please let us know via email to: paul.goulart@eng.ox.ac.uk.","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"EditURL = \"../../../../examples/jl/example_socp.jl\"","category":"page"},{"location":"examples/jl/example_socp/#SOCP-Example-in-Julia","page":"Julia","title":"SOCP Example in Julia","text":"","category":"section"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"We will show how to solve this problem both natively in Clarabel.jl and also by solving with Clarabel.jl within JuMP.","category":"page"},{"location":"examples/jl/example_socp/#Clarabel.jl-native-interface","page":"Julia","title":"Clarabel.jl native interface","text":"","category":"section"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"using Clarabel, SparseArrays\n\nP = sparse([0. 0.;0. 1.].*2)\n\nq = [0., 0.]\n\nA = sparse([0.  0.\n           -2.  0.;\n            0. -1.])\nb = [ 1.\n     -2.;\n     -2.]\n\ncones = [Clarabel.SecondOrderConeT(3)]\n\nsettings = Clarabel.Settings(max_iter = 15, verbose = true)\n\nsolver   = Clarabel.Solver()\n\nClarabel.setup!(solver, P, q, A, b, cones, settings)\n\nresult = Clarabel.solve!(solver)\n\nnothing #hide","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"result #hide","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"result.x","category":"page"},{"location":"examples/jl/example_socp/#Using-JuMP","page":"Julia","title":"Using JuMP","text":"","category":"section"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"We can solve the same problem using Clarabel.jl as the backend solver within JuMP. Here is the same problem again:","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"using Clarabel, JuMP\n\nmodel = JuMP.Model(Clarabel.Optimizer)\nset_optimizer_attribute(model, \"verbose\", true)\n\n@variable(model, x[1:2])\n@constraint(model, [1, 2x[1]-2, x[2] - 2] in SecondOrderCone())\n@objective(model, Min, x[2]^2 )\n\noptimize!(model)","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"Here is the solution","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"JuMP.value.(x)","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"and the solver termination status again","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"JuMP.termination_status(model)","category":"page"},{"location":"examples/jl/example_socp/#Using-Convex.jl","page":"Julia","title":"Using Convex.jl","text":"","category":"section"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"One more time using Clarabel.jl as the backend solver within Convex.jl:","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"using Clarabel, Convex\n\nx = Variable(2)\nproblem = minimize(square(x[2]))\nproblem.constraints = [norm([2x[1];x[2]] - [2;2], 2) <= 1]\nsolve!(problem, Clarabel.Optimizer; silent_solver = false)","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"Here is our solution","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"evaluate(x)","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"and the solver termination status again","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"problem.status","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"","category":"page"},{"location":"examples/jl/example_socp/","page":"Julia","title":"Julia","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/rs/example_powcone/","page":"Rust","title":"Rust","text":"Complete Cargo projects for all Rust examples can be found in examples/rs.","category":"page"},{"location":"examples/rs/example_powcone/","page":"Rust","title":"Rust","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/rs/example_powcone/src/main.rs\",\n  language = :rust)","category":"page"},{"location":"api_jl/#Julia-API-Reference","page":"Julia API","title":"Julia API Reference","text":"","category":"section"},{"location":"api_jl/#api-solver","page":"Julia API","title":"Solver and main API","text":"","category":"section"},{"location":"api_jl/","page":"Julia API","title":"Julia API","text":"Clarabel.Solver\nClarabel.setup!\nClarabel.solve!","category":"page"},{"location":"api_jl/#Clarabel.Solver","page":"Julia API","title":"Clarabel.Solver","text":"Solver{T <: AbstractFloat}()\n\nInitializes an empty Clarabel solver that can be filled with problem data using:\n\nsetup!(solver, P, q, A, b, cones, [settings]).\n\n\n\n\n\n","category":"type"},{"location":"api_jl/#Clarabel.setup!","page":"Julia API","title":"Clarabel.setup!","text":"setup!(solver, P, q, A, b, cones, [settings])\n\nPopulates a Solver with a cost function defined by P and q, and one or more conic constraints defined by A, b and a description of a conic constraint composed of cones whose types and dimensions are specified by cones.\n\nThe solver will be configured to solve the following optimization problem:\n\nmin   1/2 x'Px + q'x\ns.t.  Ax + s = b, s ∈ K\n\nAll data matrices must be sparse.   The matrix P is assumed to be symmetric and positive semidefinite, and only the upper triangular part is used.\n\nThe cone K is a composite cone.   To define the cone the user should provide a vector of cone specifications along with the appropriate dimensional information.   For example, to generate a cone in the nonnegative orthant followed by a second order cone, use:\n\ncones = [Clarabel.NonnegativeConeT(dim_1),\n         Clarabel.SecondOrderConeT(dim_2)]\n\nIf the argument 'cones' is constructed incrementally, the should should initialize it as an empty array of the supertype for all allowable cones, e.g.\n\ncones = Clarabel.SupportedCone[]\npush!(cones,Clarabel.NonnegativeConeT(dim_1))\n...\n\nThe optional argument settings can be used to pass custom solver settings:\n\nsettings = Clarabel.Settings(verbose = true)\nsetup!(model, P, q, A, b, cones, settings)\n\nTo solve the problem, you must make a subsequent call to solve!\n\n\n\n\n\n","category":"function"},{"location":"api_jl/#Clarabel.solve!","page":"Julia API","title":"Clarabel.solve!","text":"solve!(solver)\n\nComputes the solution to the problem in a Clarabel.Solver previously defined in setup!.\n\n\n\n\n\n","category":"function"},{"location":"api_jl/#api-cones","page":"Julia API","title":"SupportedCone","text":"","category":"section"},{"location":"api_jl/","page":"Julia API","title":"Julia API","text":"Clarabel.SupportedCone","category":"page"},{"location":"api_jl/#Clarabel.SupportedCone","page":"Julia API","title":"Clarabel.SupportedCone","text":"SupportedCone\n\nAn abstract type use by the Clarabel API used when passing cone specifications to the solver setup!. The currently supported concrete types are:\n\nZeroConeT       : The zero cone.  Used to define equalities.\nNonnegativeConeT: The nonnegative orthant.\nSecondOrderConeT: The second order / Lorentz / ice-cream cone.\nExponentialConeT:         The exponential cone (in R^3)\nPowerConeT      : The power cone with power α (in R^3)\nGenPowerConeT   : The generalized power cone \nPSDTriangleConeT: The positive semidefinite cone (triangular format).\n\n\n\n\n\n","category":"type"},{"location":"api_jl/#api-solverstatus","page":"Julia API","title":"Solver Status","text":"","category":"section"},{"location":"api_jl/","page":"Julia API","title":"Julia API","text":"Clarabel.SolverStatus","category":"page"},{"location":"api_jl/#Clarabel.SolverStatus","page":"Julia API","title":"Clarabel.SolverStatus","text":"SolverStatus\n\nAn Enum of of possible conditions set by solve!.\n\nIf no call has been made to solve!, then the SolverStatus is:\n\nUNSOLVED: The algorithm has not started.\n\nOtherwise:\n\nSOLVED                      : Solver terminated with a solution.\nPRIMAL_INFEASIBLE           : Problem is primal infeasible.  Solution returned is a certificate of primal infeasibility.\nDUAL_INFEASIBLE             : Problem is dual infeasible.  Solution returned is a certificate of dual infeasibility.\nALMOST_SOLVED               : Solver terminated with a solution (reduced accuracy).\nALMOST_PRIMAL_INFEASIBLE    : Problem is primal infeasible.  Solution returned is a certificate of primal infeasibility (reduced accuracy).\nALMOST_DUAL_INFEASIBLE      : Problem is dual infeasible.  Solution returned is a certificate of dual infeasibility (reduced accuracy).\nMAX_ITERATIONS              : Iteration limit reached before solution or infeasibility certificate found.\nMAX_TIME                    : Time limit reached before solution or infeasibility certificate found.\nNUMERICAL_ERROR             : Solver terminated with a numerical error.\nINSUFFICIENT_PROGRESS       : Solver terminated due to lack of progress.\n\n\n\n\n\n","category":"type"},{"location":"examples/py/example_socp/","page":"Python","title":"Python","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/py/example_socp.py\",\n  language = :python)","category":"page"},{"location":"examples/rs/example_qp/","page":"Rust","title":"Rust","text":"Complete Cargo projects for all Rust examples can be found in examples/rs.","category":"page"},{"location":"examples/rs/example_qp/","page":"Rust","title":"Rust","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/rs/example_qp/src/main.rs\",\n  language = :rust)","category":"page"},{"location":"user_guide_r/#user-guide-r","page":"R","title":"R Installation and User Guide","text":"","category":"section"},{"location":"user_guide_r/","page":"R","title":"R","text":"The R interface to Clarabel can be installed either directly or via CRAN.","category":"page"},{"location":"user_guide_r/","page":"R","title":"R","text":"The installation and user guide can be found here.","category":"page"},{"location":"_common/getting_started_solution_warn/","page":"-","title":"-","text":"warning: Warning\nBe careful to retrieve solver solutions from the solution that is returned by the solver, or directly from a solver object from the solver.solution field.   Do not use the solver.variables, since these have both homogenization and equilibration scaling applied and therefore do not solve the optimization problem posed to the solver.","category":"page"},{"location":"examples/example_qp/#QP-Example","page":"Problem Description","title":"QP Example","text":"","category":"section"},{"location":"examples/example_qp/","page":"Problem Description","title":"Problem Description","text":"Suppose that we want to solve the following 2-dimensional quadratic programming problem:","category":"page"},{"location":"examples/example_qp/","page":"Problem Description","title":"Problem Description","text":"beginarrayll textminimize   3x_1^2 + 2x_2^2 - x_1 - 4x_2\ntextsubject to   -1 leq x leq 1  x_1 = 2x_2\nendarray","category":"page"},{"location":"examples/example_qp/","page":"Problem Description","title":"Problem Description","text":"We will show how to solve this problem through each of Clarabel's supported languages and interfaces.","category":"page"},{"location":"examples/example_qp/","page":"Problem Description","title":"Problem Description","text":"In each case the first step is to put the problem data into the standard form expected by the solver.","category":"page"},{"location":"examples/example_qp/#Objective-function","page":"Problem Description","title":"Objective function","text":"","category":"section"},{"location":"examples/example_qp/","page":"Problem Description","title":"Problem Description","text":"The Clarabel solver's default configuration expects problem data in the form frac12x^top P x + q^top x.    We therefore define the objective function data as","category":"page"},{"location":"examples/example_qp/","page":"Problem Description","title":"Problem Description","text":"P = 2 cdot beginbmatrix 3  0  0  2endbmatrix\ntextrmand\nq = beginbmatrix -1  -4endbmatrix","category":"page"},{"location":"examples/example_qp/#Constraints","page":"Problem Description","title":"Constraints","text":"","category":"section"},{"location":"examples/example_qp/","page":"Problem Description","title":"Problem Description","text":"The solver's default configuration expects constraints in the form Ax + s = b, where s in mathcalK for some composite cone mathcalK.   We have 1 equality constraint and 4 inequalities, so we require the first element of s to be zero (i.e. the first constraint will correspond to the equality) and all other elements s_i ge 0.   Our cone constraint on s is therefore","category":"page"},{"location":"examples/example_qp/","page":"Problem Description","title":"Problem Description","text":"s in mathcal K = 0^1 times mathbbR^4_ge 0","category":"page"},{"location":"examples/example_qp/","page":"Problem Description","title":"Problem Description","text":"Define the constraint data as","category":"page"},{"location":"examples/example_qp/","page":"Problem Description","title":"Problem Description","text":"A =\nfootnotesizebeginbmatrix*r 1  -2  1  0  0  1  -1  0  0  -1endbmatrix*\ntextrmand\n b=\nfootnotesizebeginbmatrix 0  1  1  1  1 endbmatrix","category":"page"},{"location":"examples/example_qp/","page":"Problem Description","title":"Problem Description","text":"Note that Clarabel expects inputs in Compressed Sparse Column (CSC) format for both P and A.","category":"page"},{"location":"user_guide_chordal/#user-guide-chordal","page":"Chordal Decomposition","title":"Chordal Decomposition","text":"","category":"section"},{"location":"user_guide_chordal/","page":"Chordal Decomposition","title":"Chordal Decomposition","text":"Clarabel implements a chordal decomposition and clique merging method to solve large-scale semidefinite programming problems.   If the problem has favorable structure, this method can decompose a sparse positive semidefiniteness constraint on a large semidefinite cone into a collection of semidefinite constraints on a collection of smaller cones.  This can lead to significant computational savings in terms of both memory and time. ","category":"page"},{"location":"user_guide_chordal/","page":"Chordal Decomposition","title":"Chordal Decomposition","text":"Clarabel uses the same decomposition strategy as COSMO.jl.   For details see our paper on clique merging techniques and this presentation by Michael Garstka.","category":"page"},{"location":"julia/installation_jl/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"julia/installation_jl/","page":"Installation","title":"Installation","text":"Clarabel.jl can be installed using the Julia package manager for Julia v1.0 and higher. Inside the Julia REPL, type ] to enter the Pkg REPL mode then run","category":"page"},{"location":"julia/installation_jl/","page":"Installation","title":"Installation","text":"pkg> add Clarabel","category":"page"},{"location":"julia/installation_jl/","page":"Installation","title":"Installation","text":"If you want to install the latest version from the github repository run","category":"page"},{"location":"julia/installation_jl/","page":"Installation","title":"Installation","text":"pkg> add Clarabel#main","category":"page"},{"location":"python/installation_py/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"The Clarabel Python interface supports version 3.7 or newer. To install directly, use:","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"pip install clarabel","category":"page"},{"location":"python/installation_py/#Installing-from-source","page":"Installation","title":"Installing from source","text":"","category":"section"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"You can also download and build the repository directly from Github. You will need to have a working Rust installation to compile the Python interface.","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"To obtain the source:   ","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"git clone https://github.com/oxfordcontrol/Clarabel.rs\ncd Clarabel.rs","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"The Python interface to the Rust solver is implemented using PyO3 and can be built with Maturin.   First create and activate a python virtual environment for your build:","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"python3 -m venv .env\nsource .env/bin/activate","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"Install maturin in your virtual environment:","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"pip install maturin","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"Then compile the Rust source with PyO3 bindings enabled:","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"maturin develop --release ","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"To check that Clarabel works within the virtual environment, you can then run","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"python examples/python/example_qp.py","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"To compile and install the solver outside of the virtual environment, at the last step you can instead run","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"maturin build -i python --release --features python","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"inside the virtual environment to produce a .whl.   Then outside the virtual environment run","category":"page"},{"location":"python/installation_py/","page":"Installation","title":"Installation","text":"python3 -m pip install <.whl-file-you-just-built>","category":"page"},{"location":"_common/getting_started_constraints/","page":"-","title":"-","text":"The Clarabel interface expects constraints to be presented in the single vectorized form Ax + s = b s in mathcalK, where mathcalK = mathcalK_1 times dots times mathcalK_p and each mathcalK_i is one of the solver's supported cone types.","category":"page"},{"location":"_common/getting_started_constraints/","page":"-","title":"-","text":"Suppose that we have a problem with decision variable x in mathbbR^3 and our constraints are:","category":"page"},{"location":"_common/getting_started_constraints/","page":"-","title":"-","text":"A single equality constraint x_1 + x_2 - x_3 = 1.   \nA pair of inequalities such that x_2 and x_3 are each less than 2.\nA second order cone constraint on the 3-dimensional vector x.   ","category":"page"},{"location":"_common/getting_started_constraints/","page":"-","title":"-","text":"For the three constraints above, we have","category":"page"},{"location":"_common/getting_started_constraints/","page":"-","title":"-","text":"\nbeginalign*\n\nA_eq =\nleft\nbeginarraylll\n1  1  -1\nendarray\nright\nquad \nb_eq =\nleft\nbeginarrayl\n1\nendarray\nright\n\n4ex\n\nA_ineq =\nleft\nbeginarraylll\n0  1  0 \n0  0  1\nendarray\nright\nquad \nb_ineq =\nleft\nbeginarrayl\n22\nendarray\nright\n\n4ex\n\nA_soc =\nleft\nbeginarrayrrr\n-1  0  0 \n 0  -1  0 \n 0  0  -1\nendarray\nright\nquad \nb_soc =\nleft\nbeginarrayl\n0 0 0\nendarray\nright\n\nendalign*\n","category":"page"},{"location":"api_settings/#Clarabel-Solver-Settings","page":"Solver Settings","title":"Clarabel Solver Settings","text":"","category":"section"},{"location":"api_settings/","page":"Solver Settings","title":"Solver Settings","text":"The Clarabel solver supports a variety of configuration options.   The Julia, Rust and Python and interfaces all support the same set of options with identical field names.","category":"page"},{"location":"api_settings/","page":"Solver Settings","title":"Solver Settings","text":"warning: Warning\nThe solver defaults are configured to give good general performance for most problems, but  assume that the problem data is of 64 bit float type.   Although the Rust and Julia solvers  will accept 32 bit types instead (i.e. Float32 in Julia or f32 in Rust), the solver  is unlikely to perform well unless the tolerances are relaxed. ","category":"page"},{"location":"api_settings/","page":"Solver Settings","title":"Solver Settings","text":"","category":"page"},{"location":"api_settings/","page":"Solver Settings","title":"Solver Settings","text":"The full set of options follows below.","category":"page"},{"location":"api_settings/#api-settings","page":"Solver Settings","title":"Settings","text":"","category":"section"},{"location":"api_settings/","page":"Solver Settings","title":"Solver Settings","text":"Clarabel.Settings","category":"page"},{"location":"api_settings/#Clarabel.Settings","page":"Solver Settings","title":"Clarabel.Settings","text":"Argument Default Value Description\n  \nMain Algorithm Settings  \n  \nmax_iter 200 maximum number of iterations\ntime_limit Inf maximum run time (seconds)\nverbose true verbose printing\nmax_step_fraction 0.99 maximum interior point step length\n  \nFull Accuracy Settings  \ntol_gap_abs 1e-8 absolute duality gap tolerance\ntol_gap_rel 1e-8 relative duality gap tolerance\ntol_feas 1e-8 feasibility check tolerance (primal and dual)\ntol_infeas_abs 1e-8 absolute infeasibility tolerance (primal and dual)\ntol_infeas_rel 1e-8 relative infeasibility tolerance (primal and dual)\ntol_ktratio 1e-6 κ/τ tolerance\n  \nReduced Accuracy Settings  \nreduced_tol_gap_abs 5e-5 reduced absolute duality gap tolerance\nreduced_tol_gap_rel 5e-5 reduced relative duality gap tolerance\nreduced_tol_feas 1e-4 reduced feasibility check tolerance (primal and dual)\nreduced_tol_infeas_abs 5e-5 reduced absolute infeasibility tolerance (primal and dual)\nreduced_tol_infeas_rel 5e-5 reduced relative infeasibility tolerance (primal and dual)\nreduced_tol_ktratio 1e-4 reduced κ/τ tolerance\n  \nData Equilibration Settings  \nequilibrate_enable true enable data equilibration pre-scaling\nequilibrate_max_iter 10 maximum equilibration scaling iterations\nequilibrate_min_scaling 1e-4 minimum equilibration scaling allowed\nequilibrate_max_scaling 1e+4 maximum equilibration scaling allowed\n  \nStep Size Settings  \nlinesearch_backtrack_step 0.8 linesearch backtracking\nmin_switch_step_length 1e-1 minimum step size allowed for asymmetric cones with PrimalDual scaling\nmin_terminate_step_length 1e-4 minimum step size allowed for symmetric cones & asymmetric cones with Dual scaling\n  \nLinear Solver Settings  \ndirect_kkt_solver true use a direct linear solver method (required true)\ndirect_solve_method :qdldl direct linear solver (e.g. :qdldl, :mkl, :panua, :ma57, :cholmod, :faer)\nstatic_regularization_enable true enable KKT static regularization\nstatic_regularization_eps 1e-8 KKT static regularization parameter\nstatic_regularization_proportional eps(T)^2 additional regularization parameter w.r.t. the maximum abs diagonal term\ndynamic_regularization_enable true enable KKT dynamic regularization\ndynamic_regularization_eps 1e-13 KKT dynamic regularization threshold\ndynamic_regularization_delta 2e-7 KKT dynamic regularization shift\niterative_refinement_enable true KKT direct solve with iterative refinement\niterative_refinement_reltol 1e-12 iterative refinement relative tolerance\niterative_refinement_abstol 1e-12 iterative refinement absolute tolerance\niterative_refinement_max_iter 10 iterative refinement maximum iterations\niterative_refinement_stop_ratio 5.0 iterative refinement stalling tolerance\n  \n\nPreprocessing Settings  presolve_enable                         | true      | enable presolve constraint reduction ||  __Chordal Decomposition Settings|| chordal_decomposition_enable            | true            | enable chordal decomposition chordal_decomposition_mergemethod      | :cliquegraph   | chordal decomposition merge method (:none, :parentchild or :cliquegraph) chordal_decomposition_compact           | true            | assemble decomposed system in \"compact\" form chordal_decomposition_complete_dual     | false           | complete PSD dual variables after decomposition\n\n\n\n\n\n","category":"type"},{"location":"examples/py/example_qp/","page":"Python","title":"Python","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/py/example_qp.py\",\n  language = :python)","category":"page"},{"location":"examples/jl/example_powcone/","page":"Julia","title":"Julia","text":"EditURL = \"../../../../examples/jl/example_powcone.jl\"","category":"page"},{"location":"examples/jl/example_powcone/","page":"Julia","title":"Julia","text":"using Clarabel, SparseArrays\n\nP = spzeros(6,6)\n\nq = [0., 0., -1., 0., 0., -1.]\n\nA = sparse([\n       -1.  0.  0.  0.  0.  0.;\n        0. -1.  0.  0.  0.  0.;\n        0.  0. -1.  0.  0.  0.;\n        0.  0.  0. -1.  0.  0.;\n        0.  0.  0.  0. -1.  0.;\n        0.  0.  0.  0.  0. -1.;\n        1.  2.  0.  3.  0.  0.;\n        0.  0.  0.  0.  1.  0.])\n\nb = [0., 0., 0., 0., 0., 0., 3., 1.]\n\ncones  = [Clarabel.PowerConeT(0.6), Clarabel.PowerConeT(0.1), Clarabel.ZeroConeT(2)]\n\nsolver = Clarabel.Solver()\n\nsettings = Clarabel.Settings()\n\nClarabel.setup!(solver, P, q, A, b, cones, settings)\n\nresult = Clarabel.solve!(solver)\n\nnothing #hide","category":"page"},{"location":"examples/jl/example_powcone/","page":"Julia","title":"Julia","text":"result #hide","category":"page"},{"location":"examples/jl/example_powcone/","page":"Julia","title":"Julia","text":"result.x","category":"page"},{"location":"examples/jl/example_powcone/","page":"Julia","title":"Julia","text":"","category":"page"},{"location":"examples/jl/example_powcone/","page":"Julia","title":"Julia","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"EditURL = \"../convex_jl.jl\"","category":"page"},{"location":"literate/build/convex_jl/#Convex.jl-Interface","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"Clarabel.jl implements support for MathOptInterface, and is therefore compatible with Convex.jl.   This allows you to describe and modify your optimisation problem with Convex.jl and use Clarabel as the backend solver.","category":"page"},{"location":"literate/build/convex_jl/#Setting-Clarabel.jl-Backend","page":"Convex.jl Interface","title":"Setting Clarabel.jl Backend","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"You should construct your problem in the usual way in Convex.jl, and then solve using Clarabel.Optimizer, i.e. by calling solve! with","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"solve!(problem, Clarabel.Optimizer)","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"where problem is an object of type Convex.Problem.","category":"page"},{"location":"literate/build/convex_jl/#Convex.jl-or-JuMP?","page":"Convex.jl Interface","title":"Convex.jl or JuMP?","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"Clarabel.jl supports both Convex.jl and JuMP via MathOptInterface.   Both packages are excellent and can make problem construction considerably easier than via the solver's native interface.","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"For problems with quadratic objective functions, JuMP is generally preferred when using Clarabel.jl since it will keep the quadratic function in the objective rather than reformulating the problem to a form with a linear cost and additional second-order cone constraints.   Clarabel.jl natively supports quadratic objectives and solve times are generally faster if this reformulation is avoided.","category":"page"},{"location":"literate/build/convex_jl/#Arbitrary-Precision-Arithmetic","page":"Convex.jl Interface","title":"Arbitrary Precision Arithmetic","text":"","category":"section"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"Clarabel.jl supports arbitrary precision arithmetic for Convex.jl.   Here is the QP Example implemented using BigFloat types.","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"#hide setprecision(BigFloat,256)\nusing Clarabel, Convex\n\nx = Variable(2)\nobjective = 3square(x[1]) + 2square(x[2]) - x[1] - 4x[2]\nproblem = minimize(objective; numeric_type = BigFloat)\nproblem.constraints = [x[1] == 2x[2]]\nproblem.constraints += [x >= -1; x <= 1]\nsolve!(problem, Clarabel.Optimizer{BigFloat}; silent_solver = false)","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"","category":"page"},{"location":"literate/build/convex_jl/","page":"Convex.jl Interface","title":"Convex.jl Interface","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api_cone_types/#api-cone-types","page":"Supported Cone Types","title":"Supported Cone Types","text":"","category":"section"},{"location":"api_cone_types/","page":"Supported Cone Types","title":"Supported Cone Types","text":"Clarabel natively supports optimization problems with conic constraints defined on the following cones:","category":"page"},{"location":"api_cone_types/","page":"Supported Cone Types","title":"Supported Cone Types","text":"Cone Type Constructor Definition\nZero cone ZeroConeT(n)  0 ^n\nNonnegative Orthant NonnegativeConeT(n)  x in mathbbR^n  x_i ge 0 forall i=1dotsmathrmn \nSecond-Order Cone SecondOrderConeT(n)  (tx) in mathbbR^n    x_2   leq t \nExponential Cone ExponentialConeT() (x y z)  y  0 ye^xy  z \nPower Cone PowerConeT(a) (x y z)  x^a y^(1-a) geq  z (xy) geq 0  with a in (01)\nGeneralized Power Cone GenPowerConeT(a,n) (x y) in mathbbR^len(a) times mathbbR^n  prodlimits_a_i in a x_i^a_i geq y_2 x ge 0  with a_i in (01) and sum a_i = 1\nPositive Semidefinite Cone (triangular part) PSDTriangleConeT(n) Upper triangular part of the positive semidefinite cone mathbbS^n_+. The elements x of this cone represent the columnwise stacking of the upper triangular part of a positive semidefinite matrix X in mathbbS^n_+, so that x in mathbbR^d with d = n(n+1)2","category":"page"},{"location":"examples/jl/example_expcone/","page":"Julia","title":"Julia","text":"EditURL = \"../../../../examples/jl/example_expcone.jl\"","category":"page"},{"location":"examples/jl/example_expcone/","page":"Julia","title":"Julia","text":"using Clarabel, SparseArrays\n\nP = spzeros(3,3)\n\nq = [-1.,0.,0.]\n\nA = sparse([\n     -1.  0.  0.;\n      0. -1.  0.;\n      0.  0. -1.;\n      0.  1.  0.;\n      0.  0.  1.]);\n\nb = [0.,0.,0.,1.,exp(5.)];\n\ncones  = [Clarabel.ExponentialConeT(), Clarabel.ZeroConeT(2)]\n\nsolver = Clarabel.Solver()\n\nsettings = Clarabel.Settings()\n\nClarabel.setup!(solver, P, q, A, b, cones, settings)\n\nresult = Clarabel.solve!(solver)\n\nnothing #hide","category":"page"},{"location":"examples/jl/example_expcone/","page":"Julia","title":"Julia","text":"result #hide","category":"page"},{"location":"examples/jl/example_expcone/","page":"Julia","title":"Julia","text":"result.x","category":"page"},{"location":"examples/jl/example_expcone/","page":"Julia","title":"Julia","text":"","category":"page"},{"location":"examples/jl/example_expcone/","page":"Julia","title":"Julia","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/py/example_expcone/","page":"Python","title":"Python","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/py/example_expcone.py\",\n  language = :python)","category":"page"},{"location":"examples/jl/example_sdp/","page":"Julia","title":"Julia","text":"EditURL = \"../../../../examples/jl/example_sdp.jl\"","category":"page"},{"location":"examples/jl/example_sdp/#Semidefinite-Programming-(SDP)-in-Julia","page":"Julia","title":"Semidefinite Programming (SDP) in Julia","text":"","category":"section"},{"location":"examples/jl/example_sdp/","page":"Julia","title":"Julia","text":"We will show how to solve the Basic QP example problem both natively in Clarabel.jl and also by solving with Clarabel.jl within either JuMP or Convex.jl.","category":"page"},{"location":"examples/jl/example_sdp/#Clarabel.jl-native-interface","page":"Julia","title":"Clarabel.jl native interface","text":"","category":"section"},{"location":"examples/jl/example_sdp/","page":"Julia","title":"Julia","text":"using Clarabel, SparseArrays, LinearAlgebra\n\nn    = 3\nnvec = Int(n*(n+1)/2)\n\nP = spzeros(nvec,nvec)\n\nq = [1.,0.,1.,0.,0.,1.]\n\nA1 = -Diagonal([                         #<-- LHS of SDP constraint\n     1., sqrt(2), 1., sqrt(2), sqrt(2), 1.\n])\nA2 = [1. 2(2.) 3. 2(4.) 2(5.) 6.]        #<-- LHS of equality constraint\nA  = sparse([A1;A2]);\n\nb = [zeros(nvec);                       #<-- RHS of SDP constraint\n     1.]                                #<-- RHS of equality constraint\n\ncones =\n    [Clarabel.PSDTriangleConeT(n),      #<--- for the SDP constraint\n     Clarabel.ZeroConeT(1)]             #<--- for the equality constraints\n\nsettings = Clarabel.Settings()\n\nsolver   = Clarabel.Solver()\n\nClarabel.setup!(solver, P, q, A, b, cones, settings)\n\nresult = Clarabel.solve!(solver)\n\nnothing #hide","category":"page"},{"location":"examples/jl/example_sdp/","page":"Julia","title":"Julia","text":"Recover the symmetric matrix X","category":"page"},{"location":"examples/jl/example_sdp/","page":"Julia","title":"Julia","text":"X = zeros(n,n)\nX[triu(ones(Bool,3,3))] .= result.x\nX = Symmetric(X)","category":"page"},{"location":"examples/jl/example_sdp/#Using-JuMP","page":"Julia","title":"Using JuMP","text":"","category":"section"},{"location":"examples/jl/example_sdp/","page":"Julia","title":"Julia","text":"We can solve the same problem a little more easily by using Clarabel.jl as the backend solver within JuMP. Here is the same problem again. Note that we are not required to model our SDP constraint in triangular form if we are using JuMP.","category":"page"},{"location":"examples/jl/example_sdp/","page":"Julia","title":"Julia","text":"using Clarabel, JuMP\n\nn = 3\nA = [1 2 4;\n     2 3 5;\n     4 5 6]\n\nmodel = JuMP.Model(Clarabel.Optimizer)\nset_optimizer_attribute(model, \"verbose\", true)\nset_optimizer_attribute(model, \"equilibrate_enable\",false)\n\n@variable(model, X[1:n,1:n],PSD)\n@constraint(model, tr(A*X) == 1)\n@objective(model, Min, tr(X))\n\noptimize!(model)","category":"page"},{"location":"examples/jl/example_sdp/","page":"Julia","title":"Julia","text":"Here is the solution again","category":"page"},{"location":"examples/jl/example_sdp/","page":"Julia","title":"Julia","text":"JuMP.value.(X)","category":"page"},{"location":"examples/jl/example_sdp/","page":"Julia","title":"Julia","text":"","category":"page"},{"location":"examples/jl/example_sdp/","page":"Julia","title":"Julia","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/rs/example_expcone/","page":"Rust","title":"Rust","text":"Complete Cargo projects for all Rust examples can be found in examples/rs.","category":"page"},{"location":"examples/rs/example_expcone/","page":"Rust","title":"Rust","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/rs/example_expcone/src/main.rs\",\n  language = :rust)","category":"page"},{"location":"examples/rs/example_sdp/","page":"Rust","title":"Rust","text":"Complete Cargo projects for all Rust examples can be found in examples/rs.","category":"page"},{"location":"examples/rs/example_sdp/","page":"Rust","title":"Rust","text":"using Documenter\nDocumenter.md_include(\n  source = \"examples/rs/example_sdp/src/main.rs\",\n  language = :rust)","category":"page"}]
}
